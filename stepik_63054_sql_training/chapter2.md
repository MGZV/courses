# 2.1 Связи между таблицами

## Связь «один ко многим»

Рассмотрим таблицу book(в ней столбец author переименован в name_author):

|book_id|	title|	name_author	|price|	amount|
|---|---|---|---|---|
|1	|Мастер и Маргарита|	Булгаков М.А.|	670.99|	3|
|2	|Белая гвардия|	Булгаков М.А.|	540.50|	5|
|3	|Идиот	|Достоевский Ф.М.|	460.00|	10|
|4	|Братья Карамазовы|	Достоевский Ф.М.|	799.01|	2|
|5	|Стихотворения и поэмы|	Есенин С.А.|	650.00|	15|
В этой таблице фамилии авторов повторяются для нескольких книг. А что, если придется вместо инициалов для каждого автора хранить его полное имя и отчество? Тогда, если в таблице содержится информация о 50 книгах Достоевского, придется 50 раз исправлять «Ф.М.» на «Федор Михайлович». При этом, если в некоторых записях использовать «Фёдор Михайлович» (c буквой ё), то мы вообще получим двух разных авторов... 

Чтобы устранить эту проблему в реляционных базах данных создается новая таблица author,  в которой перечисляются все различные авторы, а затем эта таблица связывается с таблицей book. При этом такая связь называется «один ко многим», таблица author называется главной, таблица book – связанной или подчиненной. 

Связь «один ко многим» имеет место, когда одной записи главной таблицы соответствует несколько записей связанной таблицы, а каждой записи связанной таблицы соответствует только одна запись главной таблицы. Обозначается это так:

Этапы реализации связи «один ко многим» на следующем примере:

Один автор может написать несколько книг, а одна книга написана только одним автором. Для каждой книги известны ее количество и цена.

1. Создать таблицу author,  в которую включить уникальных авторов книг, хранящихся на складе:



2. Обе таблицы должны содержать первичный ключ, в таблице  bookон уже есть,  в таблицу authorдобавим ключ author_id:



3. Включить в таблицу book связанный столбец (внешний ключ, FOREIGN KEY), соответствующий по имени и типу ключевому столбцу главной таблицы (в нашем случае это столбец author_id). Для наглядности связь на схеме обозначается стрелкой от ключевого столбца главной таблицы к внешнему ключу связной таблицы:
---

## Связь «многие ко многим»

На предыдущем шаге мы реализовали связь «один ко многим» для книг и авторов. Она означает, что каждый автор написал несколько книг, но каждую книгу написал только один автор. На самом деле, это не совсем верное утверждение. Например, книга «12 стульев» написана двумя авторами Ильфом И.А. и Петровым Е.П. С другой стороны, эти авторы написали и другие книги, например «Золотой теленок».

Для соединения таких таблиц используется связь «многие ко многим».

Связь «многие ко многим» имеет место когда каждой записи одной таблицы соответствует несколько записей во второй, и наоборот, каждой записи второй таблицы соответствует несколько записей в первой. Обозначается это так:



Этапы реализации связи «многие ко многим»  на следующем примере:

Один автор может написать несколько книг, а одна книга может быть написана несколькими авторами. Для каждой книги известны ее количество и цена.

1. Создать таблицу author,  в которую включить уникальных авторов книг, хранящихся на складе:



2. В обеих таблицах необходимо определить первичный ключ, в нашем случае в таблице book он уже есть, поэтому достаточно включить первичный ключ author_id в таблицу author:



3. Создать новую таблицу-связку, состоящую из двух столбцов, соответствующих по имени и типу ключевым столбцам исходных таблиц. Каждый из этих столбцов является внешним ключом (FOREIGN KEY)  и связан с ключевым столбцом каждой таблицы. Для наглядности связи на схеме обозначаются стрелкой от ключевого столбца исходной таблицы к внешнему ключу связной таблицы.



4. Дальше необходимо определиться с первичным ключом таблицы-связки. Можно сделать два ключевых столбца, тогда все записи в этой таблице должны быть уникальными, то есть не повторяться. Для связи автор-книга этот вариант подходит. Но в некоторых случаях записи в таблице-связке могут повторяться, например, если мы будем продавать книги покупателям (один человек может купить несколько книг, а одну и ту же книгу могут купить несколько человек). Тогда в таблицу-связку включают дополнительные столбцы для идентификации записей, например, дату продажи,  также в таблицу-связку добавляют первичный ключ. Мы воспользуемся вторым способом:

Задание

Создать таблицу author следующей структуры:

|Поле	|Тип, описание|
|---|---|
|author_id|	INT PRIMARY KEY AUTO_INCREMENT|
|name_author	|VARCHAR(50)|

```
CREATE TABLE author(
    author_id INT PRIMARY KEY AUTO_INCREMENT, 
    name_author VARCHAR(50)   
);
```
---

Задание

Заполнить таблицу author. В нее включить следующих авторов:

| |
|---|
|Булгаков М.А.|
|Достоевский Ф.М.|
|Есенин С.А.|
|Пастернак Б.Л.|
```
INSERT INTO author (name_author) 
VALUES 
("Булгаков М.А."),
("Достоевский Ф.М."),
("Есенин С.А."),
("Пастернак Б.Л.");
```
---

## Создание таблицы с внешними ключами

При создании зависимой таблицы (таблицы, которая содержит внешние ключи) необходимо учитывать, что :

каждый внешний ключ должен иметь такой же тип данных, как связанное поле главной таблицы (в наших примерах это INT);
необходимо указать главную для нее таблицу и столбец, по которому осуществляется связь:
```
FOREIGN KEY (связанное_поле_зависимой_таблицы)  
REFERENCES главная_таблица (связанное_поле_главной_таблицы)
```
По умолчанию любой столбец, кроме ключевого, может содержать значение NULL. При создании таблицы это можно переопределить,  используя  ограничение NOT NULL для этого столбца:
```
CREATE TABLE таблица (
    столбец_1 INT NOT NULL, 
    столбец_2 VARCHAR(10) 
);
```
 В созданной таблице в столбец_1 не может содержать пустое значение, а столбец_2 - может.

Для внешних ключей рекомендуется устанавливать ограничение NOT NULL (если это совместимо с другими опциями, которые будут рассмотрены в следующем шаге).
Пример

Создать таблицу book следующей структуры:

|Поле	|Тип, описание|	Связи|
|---|---|---|
|book_id|	INT PRIMARY KEY AUTO_INCREMENT	| | 
|title	|VARCHAR(50)| |	 
|author_id|	INT |	внешний ключ: главная таблица author, связанный столбец author.author_id,
пустое значение не допускается |
|price|	DECIMAL(8, 2)| |	 
|amount|	INT| |	 
Запрос:
```
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50), 
    author_id INT NOT NULL, 
    price DECIMAL(8,2), 
    amount INT, 
    FOREIGN KEY (author_id)  REFERENCES author (author_id) 
);
```
Задание

Перепишите запрос на создание таблицы book , чтобы ее структура соответствовала структуре, показанной на логической схеме (таблица genre уже создана, порядок следования столбцов - как на логической схеме в таблице book, genre_id  - внешний ключ) . Для genre_id ограничение о недопустимости пустых значений не задавать. В качестве главной таблицы для описания поля  genre_idиспользовать таблицу genre следующей структуры:

|Поле|	Тип, описание|
|---|---|
|genre_id|	INT PRIMARY KEY AUTO_INCREMENT|
|name_genre|	VARCHAR(30)|

```
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50), 
    author_id INT NOT NULL,
    genre_id INT, 
    price DECIMAL(8,2), 
    amount INT, 
    FOREIGN KEY (author_id)  REFERENCES author (author_id),
    FOREIGN KEY (genre_id)  REFERENCES genre (genre_id)  
);
```
---

## Действия при удалении записи главной таблицы

С помощью выражения ON DELETE можно установить действия, которые выполняются для записей подчиненной таблицы при удалении связанной строки из главной таблицы. При удалении можно установить следующие опции:

- CASCADE: автоматически удаляет строки из зависимой таблицы при удалении  связанных строк в главной таблице.
- SET NULL: при удалении  связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL. (В этом случае столбец внешнего ключа должен поддерживать установку NULL).
- SET DEFAULT похоже на SET NULL за тем исключением, что значение  внешнего ключа устанавливается не в NULL, а в значение по умолчанию для данного столбца.
- RESTRICT: отклоняет удаление строк в главной таблице при наличии связанных строк в зависимой таблице.

Важно! Если для столбца установлена опция SET NULL, то при его описании нельзя задать ограничение на пустое значение.

Пример

Будем считать, что при удалении автора из таблицы author, необходимо удалить все записи о книгах из таблицы book, написанные этим автором. Данное действие необходимо прописать при создании таблицы.

Запрос:
```
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50), 
    author_id INT NOT NULL, 
    price DECIMAL(8,2), 
    amount INT, 
    FOREIGN KEY (author_id)  REFERENCES author (author_id) ON DELETE CASCADE
);
```
Задание

Создать таблицу book той же структуры, что и на предыдущем шаге. Будем считать, что при удалении автора из таблицы author, должны удаляться все записи о книгах из таблицы book, написанные этим автором. А при удалении жанра из таблицы genre для соответствующей записи book установить значение Null в столбце genre_id. 
```
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50), 
    author_id INT NOT NULL,
    genre_id INT, 
    price DECIMAL(8,2), 
    amount INT, 
    FOREIGN KEY (author_id)  REFERENCES author (author_id) ON DELETE CASCADE
    FOREIGN KEY (genre_id)  REFERENCES genre (genre_id) ON DELETE SET NULL
);
```
---

## Заполнение таблицы с внешними ключами

На предыдущих шагах были созданы и заполнены таблицы author:

|author_id	|name_author|
|---|---|
|1	|Булгаков М.А.|
|2|	Достоевский Ф.М.|
|3	|Есенин С.А.|
|4	|Пастернак Б.Л.|
и  genre:

|genre_id|	name_genre|
|---|---|
|1	|Роман|
|2	|Поэзия|

Эти таблицы являются главными для таблицы book и связаны с ней через внешние ключи:

При заполнении таблицы book в связанные столбцы необходимо заносить значения ключей главной таблицы. Например, Книгу «Игрок» написал Достоевский, поэтому значение поля author_id для этой записи должно быть  2, так как значение ключа для этого автора в таблице author равно 2. Значение поля genre_id для книги «Игрок» – 1, так как эта книга относится к жанру «Роман».

Задание

Добавьте три последние записи (с ключевыми значениями 6, 7, 8) в таблицу book, первые 5 записей уже добавлены:
```
CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50), 
    author_id INT NOT NULL,
    genre_id INT, 
    price DECIMAL(8,2), 
    amount INT, 
    FOREIGN KEY (author_id)  REFERENCES author (author_id) ON DELETE CASCADE
    FOREIGN KEY (genre_id)  REFERENCES genre (genre_id) ON DELETE SET NULL
```

```
INSERT INTO author (title, author_id, genre_id, price, amount) 
VALUES 
("Стихотворения и поэмы", 3, 2, 650.00, 15),
("Черный человек", 3, 2, 570.20, 6),
("Лирика", 4, 2, 518.99, 2);
```
===
# 2.2 Запросы на выборку, соединение таблиц

## Соединение INNER JOIN

Оператор внутреннего соединения INNER JOIN соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным.
```
SELECT
 ...
FROM
    таблица_1 INNER JOIN  таблица_2
    ON условие
...
```
Результат запроса формируется так:

- каждая строка одной таблицы сопоставляется с каждой строкой второй таблицы;
- для полученной «соединённой» строки проверяется условие соединения;
- если условие истинно, в таблицу результата добавляется соответствующая «соединённая» строка;

Пример

Вывести название книг и их авторов.

Запрос:
```
SELECT title, name_author
FROM 
    author INNER JOIN book
    ON author.author_id = book.author_id;
```
Поскольку поля author_id в таблицах book и author называются одинаково, необходимо в запросах указывать полную ссылку на них (book.author_id и author.author_id).

Задание

Вывести название, жанр и цену тех книг, количество которых больше 8, в отсортированном по убыванию цены виде.
```
SELECT title, name_genre, price
FROM 
    genre INNER JOIN book
    ON genre.genre_id = book.genre_id
WHERE amount > 8
ORDER BY price DESC;
```

## Внешнее соединение LEFT и RIGHT OUTER JOIN

Оператор внешнего соединения LEFT OUTER JOIN  (можно использовать LEFT JOIN) соединяет две таблицы. Порядок таблиц для оператора важен, поскольку оператор не является симметричным.
```
SELECT
 ...
FROM
    таблица_1 LEFT JOIN  таблица_2
    ON условие
...
```
Результат запроса формируется так:

1. в результат включается внутреннее соединение (INNER JOIN) первой и второй таблицы в соответствии с условием;
2. затем в результат добавляются те записи первой таблицы, которые не вошли во внутреннее соединение на шаге 1, для таких записей соответствующие поля второй таблицы заполняются значениями NULL.
Соединение RIGHT JOIN действует аналогично, только в пункте 2 первая таблица меняется на вторую и наоборот.

Пример

Вывести название всех книг каждого автора, если книг некоторых авторов в данный момент нет на складе – вместо названия книги указать Null.

Запрос:
```
SELECT name_author, title 
FROM author LEFT JOIN book
     ON author.author_id = book.author_id
ORDER BY name_author;     
```
Задание

Вывести все жанры, которые не представлены в книгах на складе.
```
SELECT name_genre 
FROM genre LEFT JOIN book
ON genre.genre_id = book.genre_id
WHERE title IS NULL;     
```
---
## Перекрестное соединение CROSS JOIN

Оператор перекрёстного соединения, или декартова произведения CROSS JOIN (в запросе вместо ключевых слов можно поставить запятую между таблицами) соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным. Его структура:
```
SELECT
 ...
FROM
    таблица_1 CROSS JOIN  таблица_2
...
```
или
```
SELECT
 ...
FROM
    таблица_1, таблица_2
...
```
Результат запроса формируется так: каждая строка одной таблицы соединяется с каждой строкой другой таблицы, формируя  в результате все возможные сочетания строк двух таблиц.

Например, запрос:
```
SELECT name_author, name_genre
FROM 
    author, genre;
```
каждому автору из таблицы author поставит в соответствие все возможные жанры из таблицы genre:

Задание
Есть список городов, хранящийся в таблице city:

|city_id|	name_city|
|---|---|
|1|	Москва|
|2|	Санкт-Петербург|
|3|	Владивосток|
Необходимо в каждом городе провести выставку книг каждого автора в течение 2020 года. Дату проведения выставки выбрать случайным образом. Создать запрос, который выведет город, автора и дату проведения выставки. Последний столбец назвать Дата. Информацию вывести, отсортировав сначала в алфавитном порядке по названиям городов, а потом по убыванию дат проведения выставок.

Пояснение

1. Для генерации случайной даты можно к первому числу года ('2020-01-01') прибавить целое случайное число в интервале от 0 до 365.

Генерации случайных чисел в интервале от 0 до 1 (не включительно) осуществляется с помощью функции RAND(). Если эту функцию умножить на 365, то она будет генерировать вещественные числа от 0 до 365 (не включительно). Осталось только отбросить дробную часть. Это можно сделать с помощью функции FLOOR(), которая возвращает наибольшее целое число, меньшее или равное указанному числовому значению. Таким образом, случайное число от 0 до 365 можно получить с помощью выражения:
```
FLOOR(RAND() * 365)
```
Важно! Даты должны быть за 2020 год, первое число года - 1 января 2020 года.

2. Для сложения  даты с числом используется функция:
```
DATE_ADD(дата, INTERVAL число единица_измерения),
```
где
- единица_измерения (использовать прописные буквы) – это день (DAY), месяц(MONTH), неделя(WEEK) и пр., 
- число – целое число,
- дата – значение даты или даты и времени.
Функция к дате  прибавляет указанное число, выраженное в днях, месяцах и пр. , в зависимости от заданного интервала, и возвращает новую дату.

Например:
```
DATE_ADD('2020-02-02', INTERVAL 45 DAY) возвращает 18 марта 2020 года
DATE_ADD('2020-02-02', INTERVAL 6 MONTH) возвращает 2 августа 2020 года
```

```
SELECT name_city, name_author, DATE_ADD('2020-01-01', INTERVAL FLOOR(RAND() * 365) DAY) AS Дата
FROM 
    author, city
ORDER BY name_city, Дата DESC;
```
---

## Запросы на выборку из нескольких таблиц

Запрос на выборку может выбирать данные из двух и более таблиц базы данных. При этом таблицы должны быть логически связаны между собой. Для каждой пары таблиц, включаемых в запрос, необходимо указать свой оператор соединения. Наиболее распространенным является внутреннее соединение INNER JOIN, поэтому в примерах будем использовать его.

Пусть таблицы связаны между собой следующим образом:

тогда запрос на выборку для этих таблиц будет иметь вид:
```
SELECT
 ...
FROM
    first 
    INNER JOIN  second ON first.first_id = second.first_id
    INNER JOIN  third  ON second.second_id = third.second_id
...
```
Если же таблицы связаны так:



то запрос на выборку выглядит следующим образом:
```
SELECT
 ...
FROM
    first 
    INNER JOIN  third ON first.first_id = third.first_id
    INNER JOIN second ON third.second_id = second.second_id 
...
```
В этом случае рекомендуется соединение таблиц записывать последовательно, «по кругу»: first → third → second.

Пример

Вывести информацию о тех книгах, их авторах и жанрах, цена которых принадлежит интервалу от 500  до 700 рублей  включительно.

Запрос:
```
SELECT title, name_author, name_genre, price, amount
FROM
    author 
    INNER JOIN  book ON author.author_id = book.author_id
    INNER JOIN genre ON genre.genre_id = book.genre_id
WHERE price BETWEEN 500 AND 700;
```

Задание

Вывести информацию о книгах (жанр, книга, автор), относящихся к жанру, включающему слово «роман» в отсортированном по названиям книг виде.
```
SELECT name_genre, title, name_author
FROM
    genre 
    INNER JOIN  book ON genre.genre_id = book.genre_id
    INNER JOIN author ON author.author_id = book.author_id
WHERE name_genre LIKE "%роман%"
ORDER BY title;
```
---

## Запросы для нескольких таблиц с группировкой

В запросах с групповыми функциями могут использоваться несколько таблиц, между которыми используются различные типы соединений.

Пример

Вывести количество различных книг каждого автора. Информацию отсортировать в алфавитном порядке по фамилиям  авторов.

Запрос:
```
SELECT name_author, count(title) AS Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
ORDER BY name_author;    
```
При использовании соединения INNER JOIN мы не можем узнать, что книг Лермонтова на складе нет, но предполагается, что они могут быть.  Чтобы автор Лермонтов был включен в результат, нужно изменить соединение таблиц.

Запрос:
```
SELECT name_author, count(title) AS Количество
FROM 
    author LEFT JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
ORDER BY name_author;   
```
Задание

Посчитать количество экземпляров книг каждого автора из таблицы author.  Вывести тех авторов,  количество книг которых меньше 10, в отсортированном по возрастанию количества виде. Последний столбец назвать Количество.
```
SELECT name_author, SUM(book.amount) AS Количество
FROM 
    author LEFT JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
HAVING Количество < 10 OR Количество IS NULL
ORDER BY Количество;   
```

## Запросы для нескольких таблиц со вложенными запросами

В запросах, построенных на нескольких таблицах, можно использовать вложенные запросы. Вложенный запрос может быть включен:  после ключевого слова SELECT,  после FROM и в условие отбора после WHERE (HAVING).

Пример

Вывести авторов, общее количество книг которых на складе максимально.

Это достаточно сложный запрос, поэтому будем решать его по шагам (реализуя каждый запрос по отдельности), а потом объединим все запросы в один.

Шаг 1. Найдем суммарное количество книг на складе по каждому автору. Поскольку фамилии автора в этой таблице нет, то группировку будем осуществлять по author_id.

Запрос:
```
SELECT author_id, SUM(amount) AS sum_amount FROM book GROUP BY author_id
```

Шаг 2. В результирующей таблице предыдущего запроса необходимо найти максимальное значение, то есть 23. Для этого запросу, созданному на шаге 1, необходимо присвоить имя (например, query_in) и использовать его в качестве таблицы-источника после FROM. Затем уже находить максимум по столбцу sum_amount.

Запрос:  
```
SELECT MAX(sum_amount) AS max_sum_amount
FROM 
    (
     SELECT author_id, SUM(amount) AS sum_amount 
     FROM book 
     GROUP BY author_id
    ) query_in
```
Шаг 3. Выведем фамилию автора и общее количество книг для него.

Запрос:  
```
SELECT name_author, SUM(amount) as Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
```
Шаг 4.  Включим запрос с шага 2 в условие отбора запроса с шага 3. И получим всех авторов, общее количество книг которых максимально.

Запрос:  
```
SELECT name_author, SUM(amount) as Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
HAVING SUM(amount) = 
     (/* вычисляем максимальное из общего количества книг каждого автора */
      SELECT MAX(sum_amount) AS max_sum_amount
      FROM 
          (/* считаем количество книг каждого автора */
            SELECT author_id, SUM(amount) AS sum_amount 
            FROM book GROUP BY author_id
          ) query_in
      );
```
Задание

Вывести в алфавитном порядке всех авторов, которые пишут только в одном жанре. Поскольку у нас в таблицах так занесены данные, что у каждого автора книги только в одном жанре,  для этого запроса внесем изменения в таблицу book. Пусть у нас  книга Есенина «Черный человек» относится к жанру «Роман», а книга Булгакова «Белая гвардия» к «Приключениям» (эти изменения в таблицы уже внесены).

```
SELECT name_author
FROM author 
INNER JOIN book ON author.author_id = book.author_id
INNER JOIN genre ON genre.genre_id = book.genre_id
GROUP BY name_author
HAVING COUNT( DISTINCT(name_genre))=1
ORDER BY name_author;   
```
---

## Вложенные запросы в операторах соединения

Вложенные запросы могут использоваться в операторах соединения JOIN.  При этом им необходимо присваивать имя, которое записывается сразу после закрывающей скобки вложенного запроса.
```
SELECT
 ...
FROM
    таблица ... JOIN  
       (
        SELECT ...
       ) имя_вложенного_запроса
    ON условие
...
```
Вложенный запрос может стоять как справа, так и слева от оператора JOIN. Допускается использование двух запросов в операторах соединения.

Пример

Вывести авторов, пишущих книги в самом популярном жанре. Указать этот жанр.

Шаг 1. Найдем общее количество книг по каждому жанру, отсортируем его по убыванию и ограничим вывод одной строкой. Рекомендуется, если запрос будет использоваться в качестве вложенного (особенно в операциях соединения), вычисляемым полям запроса давать собственное имя.

Запрос:
```
SELECT genre_id, SUM(amount) AS sum_amount
FROM book
GROUP BY genre_id
ORDER BY sum_amount DESC
LIMIT 1
```
Шаг 2. Используя запрос с предыдущего шага, найдем id самых популярных жанров.

Запрос:
```
SELECT query_in_1.genre_id
FROM 
    (/* выбираем код жанра и количество произведений, относящихся к нему */
      SELECT genre_id, SUM(amount) AS sum_amount
      FROM book
      GROUP BY genre_id 
    )query_in_1
    INNER JOIN
    (/* выбираем запись, в которой указан код жанр с максимальным количеством книг */
      SELECT genre_id, SUM(amount) AS sum_amount
      FROM book
      GROUP BY genre_id
      ORDER BY sum_amount DESC
      LIMIT 1
     ) query_in_2
     ON query_in_1.sum_amount= query_in_2.sum_amount        
```

Шаг 3. Используя запрос с шага 2, выведем фамилии авторов, которые пишут в самых популярных жанрах, и названия этих жанров. В этом запросе обязательно выполнить группировку по фамилиям авторов и id жанров, так как без этого фамилии авторов будут повторяться, поскольку в таблице book есть разные книги, написанные автором в одном жанре.

Запрос:
```
SELECT  name_author, name_genre
FROM 
    author 
    INNER JOIN book ON author.author_id = book.author_id
    INNER JOIN genre ON  book.genre_id = genre.genre_id
GROUP BY name_author,name_genre, genre.genre_id
HAVING genre.genre_id IN
         (/* выбираем автора, если он пишет книги в самых популярных жанрах*/
          SELECT query_in_1.genre_id
          FROM 
              ( /* выбираем код жанра и количество произведений, относящихся к нему */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
               )query_in_1
          INNER JOIN 
              ( /* выбираем запись, в которой указан код жанр с максимальным количеством книг */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
                ORDER BY sum_amount DESC
                LIMIT 1
               ) query_in_2
          ON query_in_1.sum_amount= query_in_2.sum_amount
         );   
```

Важно!

- Обратите внимание, что в группировку включен столбецgenre_id, который используется в HAVING. Это связано с тем, что в HAVING можно использовать либо столбцы, перечисленные в GROUP BY, либо вычисляемые с помощью групповых функций столбцы. Добавление столбца genre_idне влияет на группировку, так как между названием жанра и его id - взаимно-однозначное соответствие.
- Название столбца genre_id задается с указанием имени таблицы (genre.genre_id), так как этот столбец входит в структуру двух таблиц book и genre.  Для этого запроса можно было бы указать и book.genre_id, так как эти таблицы связаны внутренним соединением INNER JOIN и имеют одинаковые значения в полях genre.genre_id и book.genre_id.

Задание

Вывести информацию о книгах (название книги, фамилию и инициалы автора, название жанра, цену и количество экземпляров книги), написанных в самых популярных жанрах, в отсортированном в алфавитном порядке по названию книг виде. Самым популярным считать жанр, общее количество экземпляров книг которого на складе максимально.

```
SELECT  title, name_author, name_genre, price, amount
FROM 
    book 
    INNER JOIN author ON author.author_id = book.author_id
    INNER JOIN genre ON  book.genre_id = genre.genre_id
GROUP BY title, name_genre, name_author, genre.genre_id, price, amount
HAVING genre.genre_id IN
         (/* выбираем автора, если он пишет книги в самых популярных жанрах*/
          SELECT query_in_1.genre_id
          FROM 
              ( /* выбираем код жанра и количество произведений, относящихся к нему */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
               )query_in_1
          INNER JOIN 
              ( /* выбираем запись, в которой указан код жанр с максимальным количеством книг */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
                ORDER BY sum_amount DESC
                LIMIT 1
               ) query_in_2
          ON query_in_1.sum_amount= query_in_2.sum_amount
         )
ORDER BY 1; 
```
---

## Операция соединение, использование USING()

Данный шаг добавлен по предложениям пользователей (Валерий Родькин, Todor Illia  и другие).

При описании соединения таблиц с помощью JOIN в некоторых случаях вместо ON и следующего за ним условия можно использовать оператор USING().

USING позволяет указать набор столбцов, которые есть в обеих объединяемых таблицах. Если база данных хорошо спроектирована, а каждый внешний ключ имеет такое же имя, как и соответствующий первичный ключ (например, genre.genre_id = book.genre_id), тогда можно использовать предложение USING для реализации операции JOIN. 

При этом после SELECT, при использовании столбцов из USING(), необязательно указывать, из какой именно таблицы берется столбец.

Пример

Вывести название книг, фамилии и id их авторов.

Запрос:

Вариант с ON
```
SELECT title, name_author, author.author_id /* явно указать таблицу - обязательно */
FROM 
    author INNER JOIN book
    ON author.author_id = book.author_id;
```
Вариант с USING
```
SELECT title, name_author, author_id /* имя таблицы, из которой берется author_id, указывать не обязательно*/
FROM 
    author INNER JOIN book
    USING(author_id);
```
Запись условия соединения с ON является более общим случаем, так как

- позволяет задавать соединение не только по одноименным полям;
- позволяет использовать произвольное условие на соединение таблиц, при этом в условие может включаться произвольное выражение, например, можно указать связь двух таблиц по двум и более столбцам.

В таблице supply занесена информация о книгах, поступивших на склад.

|supply_id|	title|	author|	price	|amount|
|---|---|---|---|---|
|1|	Доктор Живаго	|Пастернак Б.Л.|	618.99|	3|
|2	|Черный человек |	Есенин С.А.	|570.20	|6|
|3|	Евгений Онегин|	Пушкин А.С.|	440.80	|5|
|4|	Идиот	|Достоевский Ф.М.|	360.80|	3|
Если в таблицах supply  и book есть одинаковые книги,  вывести их название и автора. При этом учесть, что у нескольких авторов могут быть книги с одинаковым названием.

Важно. В данном примере для соединения book и supply использовать USING нельзя, так как: 

в таблице book фамилий авторов вообще нет (их необходимо получить из таблицы author, столбец name_author),  а в таблице supply фамилии занесены в столбец author;
для однозначной идентификации книги нужно указать, что совпадают не только названия, но и авторы книг.
Запрос:
```
SELECT book.title, name_author
FROM 
    author 
    INNER JOIN book USING (author_id)   
    INNER JOIN supply ON book.title = supply.title 
                         and author.name_author = supply.author;
```

Задание

Если в таблицах supply  и book есть одинаковые книги, которые имеют равную цену,  вывести их название и автора, а также 
посчитать общее количество экземпляров книг в таблицах supply и book, столбцы назвать Название, Автор  и Количество.
```
SELECT book.title AS Название, name_author AS Автор, book.amount + supply.amount AS Количество
FROM 
    author 
    INNER JOIN book USING (author_id)   
    INNER JOIN supply ON book.title = supply.title 
                         and book.price = supply.price;
```
---

## Запросы на обновление, связанные таблицы

В запросах на обновление можно использовать связанные таблицы:
```
UPDATE таблица_1
     ... JOIN таблица_2
     ON выражение
     ...
SET ...   
WHERE ...;
```
При этом исправлять данные можно во всех используемых в запросе таблицах.

Пример

Для книг, которые уже есть на складе (в таблице book) по той же цене, что и в поставке (supply), увеличить количество на значение, указанное в поставке, а также обнулить количество этих книг в поставке.

Этот запрос должен отобрать строки из таблиц bookи supply такие, что у них совпадают и автор, и название книги. Но в таблице supply фамилия автора записана не числом (id), а текстом. Следовательно, чтобы выполнить сравнение по фамилии автора нужно "подтянуть" таблицу author,  которая связана с bookпо столбцу author_id.  И в логическом выражении, описывающем соединение таблиц, можно будет использовать столбцы из таблиц book, authorи supply. 

Если таблицы логически связаны по двум и более столбцам (на рисунке связи обозначены линиями), возможно через другие таблицы, условие соединение будет включать связи по нужным столбцам через логический оператор AND. Например, для следующих таблиц логическую связь по названию и автору:



условие соединения можно записать в виде:
```
book INNER JOIN author ON author.author_id = book.author_id
     INNER JOIN supply ON book.title = supply.title 
                          and supply.author = author.name_author
```
Запрос:
```
UPDATE book 
     INNER JOIN author ON author.author_id = book.author_id
     INNER JOIN supply ON book.title = supply.title 
                         and supply.author = author.name_author
SET book.amount = book.amount + supply.amount,
    supply.amount = 0   
WHERE book.price = supply.price;

SELECT * FROM book;

SELECT * FROM supply;
```
Задание
Для книг, которые уже есть на складе (в таблице book), но по другой цене, чем в поставке (supply),  необходимо 
в таблице book увеличить количество на значение, указанное в поставке,  и пересчитать цену. А в таблице  supply обнулить количество этих книг. Формула для пересчета цены:

где  p1, p2 - цена книги в таблицах book и supply;

k1, k2 - количество книг в таблицах book и supply.

```
UPDATE book 
     INNER JOIN author ON author.author_id = book.author_id
     INNER JOIN supply ON book.title = supply.title 
                         and supply.author = author.name_author
SET book.price = (book.amount * book.price + supply.amount * supply.price)/(supply.amount + book.amount),
    book.amount = book.amount + supply.amount,
    supply.amount = 0   
WHERE book.price <> supply.price;

SELECT * FROM book;

SELECT * FROM supply;
```
---

## Запросы на добавление, связанные таблицы

Запросом на добавление можно добавить записи, отобранные с помощью запроса на выборку, который включает несколько таблиц:
```
INSERT INTO таблица (список_полей)
SELECT список_полей_из_других_таблиц
FROM 
    таблица_1 
    ... JOIN таблица_2 ON ...
    ...
```
Пример

В таблице supply  есть новые книги, которых на складе еще не было. Прежде чем добавлять их в таблицу book,  необходимо
из таблицы supplyотобрать новых авторов, если таковые имеются.

Запрос:
```
SELECT name_author, supply.author
FROM 
    author 
    RIGHT JOIN supply ON author.name_author = supply.author;
```
Поскольку таблица author и поле в таблице supply называются одинаково, желательно указывать полную ссылку на поле (supply.author), чтобы запрос был более читабельным.

Выполнив правое внутреннее соединение таблиц, получили значение Null (None) в поле name_author в строке того автора, которого нет в таблице author, в нашем случае это Стивенсон.

Теперь достаточно в запросе задать условие отбора, и список новых авторов готов для включения в таблицу author.

Запрос:
```
SELECT supply.author
FROM 
    author 
    RIGHT JOIN supply on author.name_author = supply.author
WHERE name_author IS Null;
```
Задание

Включить новых авторов в таблицу author с помощью запроса на добавление, а затем вывести все данные из таблицы author. 
Новыми считаются авторы, которые есть в таблице supply, но нет в таблице author.

```
INSERT INTO author (name_author)
SELECT supply.author
FROM 
    author 
    RIGHT JOIN supply on author.name_author = supply.author
WHERE name_author IS Null;
```
---

## Запрос на добавление, связанные таблицы

Следующий шаг - добавить новые записи о книгах, которые есть в таблице supply и нет в таблице book. (В таблицах supply и book сохранены изменения предыдущих шагов). Поскольку в таблице supply не указан жанр книги, оставить его пока пустым (занести значение Null).

Пример

Прежде всего необходимо сформировать запрос с полями, которые соответствуют полям таблицы book, так как использовать только таблицу supply нельзя - в ней вместо кода автора стоит его фамилия. 

Запрос:
```
SELECT title, author_id, price, amount
FROM 
    author 
    INNER JOIN supply ON author.name_author = supply.author;
```
Далее необходимо отобрать только новые книги из таблицы supply. Как видно из таблицы с результатами запроса, в тех записях, которые нужно добавить, значения столбца amount не равны 0 (количество уже учтенных книг обнулены предыдущим запросом). Добавим это условие в запрос.

Запрос:
```
SELECT title, author_id, price, amount
FROM 
    author 
    INNER JOIN supply ON author.name_author = supply.author
WHERE amount <> 0;
```
Задание

Добавить новые книги из таблицы supply в таблицу book на основе сформированного выше запроса. 
Затем вывести для просмотра таблицу book.
```
INSERT INTO book (title, author_id, price, amount )
SELECT title, author_id, price, amount
FROM 
    author 
    INNER JOIN supply ON author.name_author = supply.author
WHERE amount <> 0;

SELECT * FROM book
```
---

## Запрос на обновление, вложенные запросы

После того, как новые книги добавлены в таблицу book, нужно указать к какому жанру они относятся. Для этого используется запрос на обновление, в котором можно указать значения столбцов из других таблиц, либо использовать вложенные запросы для получения этих значений.

Пример

Задать для книги Пастернака «Доктор Живаго» жанр «Роман».

Если мы знаем код этой книги в таблице book (в нашем случае это 9) и код жанра «Роман» в таблице genre (это 1), запрос будет очень простым.

Запрос:
```
UPDATE book
SET genre_id = 1
WHERE book_id = 9;

SELECT * FROM book;
```
Более сложным будет запрос, если известно только название жанра (результат будет точно таким же):

Запрос:
```
UPDATE book
SET genre_id = 
      (
       SELECT genre_id 
       FROM genre 
       WHERE name_genre = 'Роман'
      )
WHERE book_id = 9;

SELECT * FROM book;
```
Задание

 Занести для книги «Стихотворения и поэмы» Лермонтова жанр «Поэзия», а для книги 
«Остров сокровищ» Стивенсона - «Приключения». (Использовать два запроса).
```
UPDATE book
SET genre_id = 
      (
       SELECT genre_id 
       FROM genre 
       WHERE name_genre = 'Поэзия'
      )
WHERE title = "Стихотворения и поэмы" AND author_id = 5;

UPDATE book
SET genre_id = 
      (
       SELECT genre_id 
       FROM genre 
       WHERE name_genre = 'Приключения'
      )
WHERE title = "Остров сокровищ" AND author_id = 6;
SELECT * FROM book;
```
---

## Каскадное удаление записей связанных таблиц

При создании таблицы для внешних ключей с помощью ON DELETE устанавливаются опции, которые определяют действия , выполняемые при удалении связанной строки из главной таблицы.

В частности, ON DELETE CASCADE автоматически удаляет строки из зависимой таблицы при удалении  связанных строк в главной таблице.

В таблице book эта опция установлена для поля author_id.

Пример

Удалим из таблицы author всех авторов, фамилия которых начинается на «Д», а из таблицы book  - все книги этих авторов.

Запрос:
```
DELETE FROM author
WHERE name_author LIKE "Д%";

SELECT * FROM author;

SELECT * FROM book;
```
Одним запросом удаляются связанные записи из главной и зависимой таблицы. 
В нашем случае удалился автор Достоевский и все его книги.

Задание

Удалить всех авторов и все их книги, общее количество книг которых меньше 20.
```
DELETE FROM author

WHERE author_id IN (
        SELECT author_id 
        FROM book
        GROUP BY author_id
        HAVING SUM(amount)<20
      );

SELECT * FROM author;

SELECT * FROM book;
```
---

## Удаление записей главной таблицы с сохранением записей в зависимой

При создании таблицы для внешних ключей с помощью ON DELETE устанавливаются опции, которые определяют действия, выполняемые при удалении связанной строки из главной таблицы.

Если задано SET NULL, то при удалении связанной строки из главной таблицы в зависимой, в столбце внешнего ключа, устанавливается значение NULL. (При этом в столбце внешнего ключа должно быть допустимо значение NULL)

В таблице book эта опция установлена на поле genre_id.

Пример

Удалим из таблицы genre все  жанры, название которых заканчиваются на «я» , а в таблице book  -  для этих жанров установим значение Null.

Запрос:
```
DELETE FROM genre
WHERE name_genre LIKE "%я";

SELECT * FROM genre;

SELECT * FROM book;
```

Задание

Удалить все жанры, к которым относится меньше 4-х книг. 
В таблице book для этих жанров установить значение Null.
```
DELETE FROM genre

WHERE genre_id IN (
        SELECT genre_id 
        FROM book
        GROUP BY genre_id
        HAVING COUNT(title)<4
      );

SELECT * FROM genre;

SELECT * FROM book;
```
---

## Удаление записей, использование связанных таблиц

При удалении записей из таблицы можно использовать информацию из других связанных с ней таблиц. В этом случае синтаксис запроса имеет вид:
```
DELETE FROM таблица_1
USING 
    таблица_1 
    INNER JOIN таблица_2 ON ...
WHERE ...
```
Пример

Удалить всех авторов из таблицы author, у которых есть книги, количество экземпляров которых меньше 3. Из таблицы book удалить все книги этих авторов.

Запрос:
```
DELETE FROM author
USING 
    author 
    INNER JOIN book ON author.author_id = book.author_id
WHERE book.amount < 3;

SELECT * FROM author;

SELECT * FROM book;
```
Задание

Удалить всех авторов, которые пишут в жанре "Поэзия". Из таблицы book удалить все книги этих авторов. 
В запросе для отбора авторов использовать полное название жанра, а не его id.
```
DELETE FROM author
USING 
    author 
    INNER JOIN book ON author.author_id = book.author_id
    INNER JOIN genre ON genre.genre_id = book.genre_id
WHERE genre.name_genre = "Поэзия";

SELECT * FROM author;

SELECT * FROM book;
```
---

# 2.4 База данных «Интернет-магазин книг», запросы на выборку

Проектирование концептуальной модели базы данных
Шаг 1. Детально проанализировать предметную область и выделить те информационные объекты, которые будут храниться в базе данных (выделены зеленым):

В интернет-магазине продаются книги. Каждая книга имеет название, написана одним автором, относится к одному жанру, имеет определенную цену. В магазине в наличии есть несколько экземпляров каждой книги. 

Покупатель регистрируется на сайте интернет-магазина, задает свое имя и фамилию,  электронную почту и город проживания (для упрощения считаем, что человек не может поменять свой город проживания). Он может сформировать один или несколько заказов,  для каждого заказа написать какие-то пожелания. Каждый заказ включает одну или несколько книг, каждую книгу можно заказать в нескольких экземплярах. Затем заказ проходит ряд последовательных этапов (операций): оплачивается, упаковывается, передается курьеру или транспортной компании для транспортировки и, наконец, доставляется покупателю. Фиксируется дата каждой операции. Для каждого города известно среднее время доставки книг.

При этом в магазине ведется учет книг, при покупке их количество уменьшается, при поступлении товара увеличивается, при исчерпании количества – оформляется заказ и пр.

Шаг 2. Для каждого выделенного информационного объекта указать его характеристики, для этого:

а) сначала выделить их в описании предметной области (синий цвет): 

В интернет-магазине продаются книги. Каждая книга имеет название, написана одним автором, относится к одному жанру, имеет определенную цену. В магазине в наличии есть несколько экземпляров каждой книги. 

Покупатель регистрируется на сайте интернет-магазина, задает свое имя и фамилию,  электронную почту и город проживания. Он может сформировать один или несколько заказов, для каждого заказа написать какие-то пожелания. Каждый заказ включает одну или несколько книг, каждую книгу можно заказать в нескольких экземплярах. Затем заказ проходит ряд последовательных этапов(операций): оплачивается, упаковывается, передается курьеру или транспортной компании для транспортировки и, наконец, доставляется покупателю. Фиксируется дата каждой операции. Для каждого города известно среднее время доставки книг.

При этом в магазине ведется учет книг, при покупке их количество уменьшается, при поступлении товара увеличивается, при исчерпании количества – оформляется заказ и пр.

б) затем связать их с информационным объектом: 

Книга – название, количество, цена;
Автор – фамилия и инициалы;
Жанр – название;
Покупатель (клиент) – фамилия и имя, электронная почта;
Город – название, среднее время доставки;
Заказ – код заказа, пожелания;
Этап – название этапов.
в) перечислить характеристики, которые остались не привязанными к информационным объектам (к ним необходимо вернуться при реализации связей между таблицами): 

книги в заказе;
количество книг в заказе;
дата каждой операции.
Шаг 3. Нарисовать схему, на которой изобразить информационные объекты в виде прямоугольников:

Шаг 4. Установить связи между информационными объектами. Связь «один ко многим» обозначить в виде →, «многие ко многим» –  ↔.

Каждая книга написана одним автором, каждый автор написал несколько книг, следовательно между этими таблицами связь «один ко многим»:


Каждая книга может включаться в несколько заказов, один заказ может содержать несколько книг, между этими таблицами связь «многие ко многим»:


Каждый клиент может сформировать несколько заказов, каждый заказ формируется только одним клиентом:

Пример

Вывести фамилии всех клиентов, которые заказали книгу Булгакова «Мастер и Маргарита».

Запрос:

Этот запрос строится на основе нескольких таблиц, для удобства нужно определить фрагмент логической схемы базы данных, на основе которой строится запрос. В нашем случае выбираются название книги из таблицы book и фамилия клиента из таблицы client. Эти таблицы между собой непосредственно не связаны, поэтому нужно добавить «связующие» таблицы  buy и buy_book:

## Запросы на основе трех и более связанных таблиц

Для соединения этих таблиц используется INNER JOIN. Для удобства рекомендуется связи описывать последовательно: client → buy → buy_book → book.  А для соединения использовать пару первичный ключ и внешний ключ соответствующих таблиц. Например, соединение таблиц client и buy осуществляется по условию client.client_id = buy.client_id.

Чтобы не усложнять схему, будем считать, что нам известен id Булгакова (это 1)
```
SELECT DISTINCT name_client
FROM 
    client 
    INNER JOIN buy ON client.client_id = buy.client_id
    INNER JOIN buy_book ON buy_book.buy_id = buy.buy_id
    INNER JOIN book ON buy_book.book_id=book.book_id
WHERE title ='Мастер и Маргарита' and author_id = 1;
```                    
В запросе отбираются уникальные клиенты (DISTINCT) так как один и тот же клиент мог заказать одну и ту же книгу несколько раз.

Задание

Вывести все заказы Баранова Павла (id заказа, какие книги,
по какой цене и в каком количестве он заказал) в отсортированном по номеру заказа и названиям книг виде.

```
SELECT buy_book.buy_id, book.title, book.price, buy_book.amount
FROM 
    client 
    INNER JOIN buy ON client.client_id = buy.client_id
    INNER JOIN buy_book ON buy_book.buy_id = buy.buy_id
    INNER JOIN book ON buy_book.book_id=book.book_id
WHERE client.name_client ='Баранов Павел'
ORDER BY buy_book.buy_id, book.title;
```  
Задание

Посчитать, сколько раз была заказана каждая книга, для книги вывести ее автора (нужно посчитать,
в каком количестве заказов фигурирует каждая книга).  
Вывести фамилию и инициалы автора, название книги, 
последний столбец назвать Количество. Результат отсортировать сначала  по фамилиям авторов, 
а потом по названиям книг.

COALESCE(выражение_которое_может_вернуть_None, на_что_меняем_None)
```
SELECT author.name_author, book.title, COUNT(buy_book.amount) AS Количество
FROM 
    author 
    INNER JOIN book ON book.author_id = author.author_id
    LEFT JOIN buy_book ON buy_book.book_id = book.book_id
GROUP BY author.name_author, book.title
ORDER BY author.name_author, book.title;
```
```
SELECT author.name_author, book.title, COUNT(buy_book.amount) AS Количество
FROM 
    author 
    INNER JOIN book USING(author_id)
    LEFT JOIN buy_book USING(book_id)
GROUP BY 1, 2
ORDER BY 1, 2;
```








































