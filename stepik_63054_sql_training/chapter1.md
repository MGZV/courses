# 1. Основы реляционной модели и SQL

[Интерактивный тренажер по SQL](https://stepik.org/course/63054/)

[Поиск по ключевым словам](https://stepik.org/lesson/583183/step/2)

_https://www.sqlstyle.guide/ru/_ - руководство по стилю

отношение – это структура данных целиком, набор записей (в обычном понимании – таблица) , в примере –это Сотрудник;

кортеж – это каждая строка , содержащая данные (более распространенный термин – запись ), например, <001, Борин С.А,
234-01-23, программист>, все кортежи в отношении должны быть различны;

мощность – число кортежей в таблице (проще говоря, число записей), в данном случае 3, мощность отношения может быть
любой (от 0 до бесконечности), порядок следования кортежей - неважен;

атрибут – это столбец в таблице (более распространенный термин – поле ), в примере – Табельный номер, Фамилия И.О.,
Телефон, Должность)

размерность – это число атрибутов в таблице, в данном случае – 4; размерность отношения должна быть больше 0, порядок
следования атрибутов существенен;

домен атрибута – это допустимые значения (неповторяющиеся), которые можно занести в поле , например для атрибута
Должность домен – {инженер, программист}.

домен - это значение в таблице

---

## 1.1 Отношение(таблица)

---

### Создание таблицы

Для создания таблицы используется SQL-запрос. В нем указывается какая таблица создается, из каких атрибутов(полей) она
состоит и какой тип данных имеет каждое поле, при необходимости указывается описание полей (ключевое поле и т.д.). Его
структура :

- ключевые слова : CREATE TABLE
- имя создаваемой таблицы;
- открывающая круглая скобка «(»;
- название поля и его описание, которое включает тип поля и другие необязательные характеристики;
- запятая;
- название поля и его описание;
- ...
- закрывающая скобка «)».

Пример. Создадим таблицу genre следующей структуры:

```
CREATE TABLE genre(
    genre_id INT PRIMARY KEY AUTO_INCREMENT, 
    name_genre VARCHAR(30)
);
```

```
CREATE TABLE book(
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50),
    author VARCHAR(30),
    price DECIMAL(8,2),
    amount INT
);
```

закомментировать, используя /* и */ или --

---

### Вставка записи в таблицу

Для занесения новой записи в таблицу используется SQL запрос, в котором указывается в какую таблицу, в какие поля
заносить новые значения. Структура запроса:

- ключевые слова INSERT INTO (ключевое слово INTO можно пропустить);
- имя таблицы, в которую добавляется запись;
- открывающая круглая скобка «(»;
- список полей через запятую, в которые следует занести новые данные;
- закрывающая скобка «)»;
- ключевое слово VALUES;
- открывающая круглая скобка «(»;
- список значений через запятую, которые заносятся в соответствующие поля, при этом текстовые значения заключаются в
  кавычки, числовые значения записываются без кавычек, в качестве разделителя целой и дробной части используется точка;
- закрывающая скобка «)».

```
INSERT INTO genre (name_genre) 
VALUES ('Роман');
```

```
INSERT INTO book (title, author, price, amount) 
VALUES ("Мастер и Маргарита", "Булгаков М.А.", 670.99, 3);
```

```
INSERT INTO book (title, author, price, amount) 
VALUES 
("Белая гвардия", "Булгаков М.А.", 540.50, 5),
("Идиот", "Достоевский Ф.М.", 460.00, 10),
("Братья Карамазовы", "Достоевский Ф.М.", 799.01, 2);
```

---

## 1.2 Выборка данных

---

### Выборка всех данных из таблицы

Для того чтобы отобрать все данные из таблицы используется SQL запрос следующей структуры:

- ключевое слово SELECT;
- символ « *» ;
- ключевое слово FROM;
- имя таблицы.

Результатом является таблица, в которую включены все строки и столбцы указанной в запросе таблицы.

`SELECT * FROM book;`

---

### Выборка отдельных столбцов

Для того чтобы отобрать данные из определенных столбцов таблицы используется SQL запрос следующей структуры:

- ключевое слово SELECT ;
- список столбцов таблицы через запятую;
- ключевое слово FROM ;
- имя таблицы.

Результатом является таблица, в которую включены все данные из указанных после SELECT столбцов исходной таблицы.

`SELECT title, amount FROM book;`

`SELECT author, title, price FROM book;`

---

### Выборка новых столбцов и присвоение им новых имен

Для того чтобы отобрать данные из определенных столбцов таблицы и одновременно задать столбцам новые имена используется
SQL запрос следующей структуры:

- ключевое слово SELECT ;
- имя столбца;
- ключевое слово AS ;
- новое название столбца (можно русскими буквами), но это должно быть одно слово, если название состоит из двух слов –
  соединяйте их подчеркиванием, например, Количество_книг ;
- запятая;
- имя столбца;
- .... 
- ключевое слово FROM ;
- имя таблицы.

В одном запросе можно использовать и имена столбцов из таблицы, и новые названия.

Результатом является таблица, в которую включены все данные из указанных после SELECT столбцов исходной таблицы. Каждому
столбцу присваивается новое имя, заданное после AS, или столбец получает имя столбца исходной таблицы, если AS
отсутствует.

`SELECT title AS Название, amount FROM book;`

`SELECT title AS Название, author AS Автор FROM book;`

---

### Выборка данных с созданием вычисляемого столбца

С помощью SQL запросов можно осуществлять вычисления по каждой строке таблицы с помощью вычисляемого столбца. Для него в
списке полей после оператора SELECT указывается выражение и задается имя.

Выражение может включать имена столбцов, константы, знаки операций, встроенные функции.

Результатом является таблица, в которую включены все данные из указанных после SELECT столбцов, а также новый столбец, в
каждой строке которого вычисляется заданное выражение.

```
SELECT title, author, price, amount, 
     price * amount AS total 
FROM book;
```

```
SELECT title, amount, 
     1.65 * amount AS pack 
FROM book;
```

---

### Выборка данных, вычисляемые столбцы, математические функции

https://docs.microsoft.com/ru-ru/sql/t-sql/functions/mathematical-functions-transact-sql?view=sql-server-ver15
В SQL реализовано множество математических функций для работы с числовыми данными.

```
SELECT title, price, 
    (price*18/100)/(1+18/100) AS tax, 
    price/(1+18/100) AS price_tax 
FROM book;
```

Сумма налога и цена книги без налога – это деньги, поэтому количество знаков после запятой у этих чисел должно быть 2.
Следовательно необходимо округлить полученные значения.

```
SELECT title, 
    price, 
    ROUND((price*18/100)/(1+18/100),2) AS tax, 
    ROUND(price/(1+18/100),2) AS price_tax 
FROM book;
```

В конце года цену всех книг на складе пересчитывают – снижают ее на 30%. Написать SQL запрос, который из таблицы book
выбирает названия, авторов, количества и вычисляет новые цены книг. Столбец с новой ценой назвать new_price, цену
округлить до 2-х знаков после запятой.

```
SELECT title, author,
    amount, 
    ROUND(price*0.7 ,2) AS new_price    
FROM book;
```

---

### Выборка данных, вычисляемые столбцы, логические функции

В SQL реализована возможность заносить в поле значение в зависимости от условия. Для этого используется функция IF:

IF(логическое_выражение, выражение_1, выражение_2)
Функция вычисляет логическое_выражение, если оно истина – в поле заносится значение выражения_1, в противном случае –
значение выражения_2. Все три параметра IF() являются обязательными.

Допускается использование вложенных функций, вместо выражения_1 или выражения_2 может стоять новая функция IF.

Пример

Для каждой книги из таблицы book установим скидку следующим образом: если количество книг меньше 4, то скидка будет
составлять 50% от цены, в противном случае 30%.

Запрос:

```
SELECT title, amount, price, 
    IF(amount<4, price*0.5, price*0.7) AS sale
FROM book;
```

Цена по скидке должна отображаться с двумя знаками после запятой, добавим в запрос округление:

```
SELECT title, amount, price, 
    ROUND(IF(amount<4, price*0.5, price*0.7),2) AS sale
FROM book;
```

Усложним вычисление скидки в зависимости от количества книг. Если количество книг меньше 4 – то скидка 50%, меньше 11 –
30%, в остальных случаях – 10%. И еще укажем какая именно скидка на каждую книгу.

Запрос:

```
SELECT title, amount, price,
    ROUND(IF(amount < 4, price * 0.5, IF(amount < 11, price * 0.7, price * 0.9)), 2) AS sale,
    IF(amount < 4, 'скидка 50%', IF(amount < 11, 'скидка 30%', 'скидка 10%')) AS Ваша_скидка
FROM book;
```

```
SELECT author, title,
    ROUND(IF(author = "Булгаков М.А.", price * 1.1, IF(author = "Есенин С.А.", price * 1.05, price)), 2) AS new_price
FROM book;
```

---

### Выборка данных по условию

С помощью запросов можно включать в итоговую выборку не все строки исходной таблицы, а только те, которые отвечают
некоторому условию. Для этого после указания таблицы, откуда выбираются данные, задается ключевое слово WHERE и
логическое выражение, от результата которого зависит будет ли включена строка в выборку или нет. Если условие – истина,
то строка(запись) включается в выборку, если ложь – нет.

Логическое выражение может включать операторы сравнения (равно «=», не равно «<>», больше «>», меньше «<», больше или
равно«>=», меньше или равно «<=») и выражения, допустимые в SQL.

Пример

Вывести название и цену тех книг, цены которых меньше 600 рублей.

```
SELECT title, price 
FROM book
WHERE price < 600;
```

Пример

Вывести название, автора и стоимость (цена умножить на количество) тех книг, стоимость которых больше 4000 рублей

Запрос:

```
SELECT title, author, price * amount AS total
FROM book
WHERE price * amount > 4000;
```

Задание

Вывести автора, название и цены тех книг, количество которых меньше 10.

```
SELECT author, title, price
FROM book
WHERE amount < 10;
```

---

### Выборка данных, логические операции

Логическое выражение после ключевого слова WHERE кроме операторов сравнения и выражений может включать логические
операции (И «and», ИЛИ «or», НЕ «not») и круглые скобки, изменяющие приоритеты выполнения операций.

Приоритеты операций:

- круглые скобки
- умножение (*), деление (/)
- сложение  (+), вычитание (-)
- операторы сравнения (=, >, <, >=, <=, <>)
- NOT
- AND
- OR

Пример

Вывести название, автора и цену тех книг, которые написал Булгаков, ценой больше 600 рублей

Запрос:

```
SELECT title, author, price 
FROM book
WHERE price > 600 AND author = 'Булгаков М.А.';
```

Вывести название, цену тех книг, которые написал Булгаков или Есенин, ценой больше 600 рублей

Запрос:

```
SELECT title, author, price 
FROM book
WHERE (author = 'Булгаков М.А.' OR author = 'Есенин С.А.') AND price > 600;
```

Задание

Вывести название, автора, цену и количество всех книг, цена которых меньше 500 или больше 600, а стоимость всех
экземпляров этих книг больше или равна 5000.

```
SELECT title, author, price, amount 
FROM book
WHERE (price < 500 OR price >= 600) AND price * amount >= 5000;
```

---

### Выборка данных, операторы BETWEEN, IN

Логическое выражение после ключевого слова WHERE может включать операторы BETWEEN и IN. Приоритет у этих операторов
такой же как у операторов сравнения, то есть они выполняются раньше, чем NOT, AND, OR.

Оператор BETWEEN позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.

Пример

Выбрать названия и количества тех книг, количество которых от 5 до 14 включительно.

Запрос:

```
SELECT title, amount 
FROM book
WHERE amount BETWEEN 5 AND 14;
```

Этот запрос можно реализовать по-другому, результат будет точно такой же.

```
SELECT title, amount 
FROM book
WHERE amount >= 5 AND amount <=14;
```

Оператор IN позволяет выбрать данные, соответствующие значениям из списка.

Пример

Выбрать названия и цены книг, написанных Булгаковым или Достоевским.

Запрос:

```
SELECT title, price 
FROM book
WHERE author IN ('Булгаков М.А.', 'Достоевский Ф.М.');
```

Этот запрос можно реализовать по-другому, результат будет точно такой же.

```
SELECT title, price 
FROM book
WHERE author = 'Булгаков М.А.' OR author = 'Достоевский Ф.М.';
```

Задание

Вывести название и авторов тех книг, цены которых принадлежат интервалу от 540.50 до 800 (включая границы), а количество
или 2, или 3, или 5, или 7.

```
SELECT title, author 
FROM book
WHERE price BETWEEN 540.50 AND 800 AND amount IN (2, 3, 5, 7);
```

---

### Выборка данных с сортировкой

При выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать отобранные строки. Для
этого используются ключевые слова ORDER BY, после которых задаются имена столбцов. При этом строки сортируются по
первому столбцу, если указан второй столбец, сортировка осуществляется только для тех строк, у которых значения первого
столбца одинаковы. По умолчанию ORDER BY выполняет сортировку по возрастанию. Чтобы управлять направлением сортировки
вручную, после имени столбца указывается ключевое слово ASC (по возрастанию) или DESC (по убыванию).

Логический порядок операций для запроса SQL следующий:

- FROM
- WHERE
- SELECT
- ORDER BY

Поскольку сортировка выполняется позже SELECT, для указания столбцов, по которым выполняется сортировка, можно
использовать имена, присвоенные им после SELECT, а также порядковый номер столбца в перечислении.

Пример

Вывести название, автора и цены книг. Информацию отсортировать по названиям книг в алфавитном порядке.

Запрос:

```
SELECT title, author, price
FROM book
ORDER BY title;
```

Аналогичный результат получится при использовании запроса:

```
SELECT title, author, price
FROM book
ORDER BY 1;
```

Пример

Вывести автора, название и количество книг, в отсортированном в алфавитном порядке по автору и по убыванию количества,
для тех книг, цены которых меньше 750 рублей.

Запрос:

```
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, amount DESC;
```

Можно использовать другие варианты записи запроса:

```
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, Количество DESC;
```

```
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY 1, 3 DESC;
```

Задание

Вывести автора и название книг, количество которых принадлежит интервалу от 2 до 14 (включая границы). Информацию
отсортировать сначала по авторам (в обратном алфавитном порядке), а затем по названиям книг (по алфавиту).

```
SELECT author, title
FROM book
WHERE amount BETWEEN 2 AND 14
ORDER BY author DESC, title;
```
---

### Выборка данных, оператор LIKE

Оператор LIKE используется для сравнения строк. В отличие от операторов отношения равно (=) и не равно (<>), LIKE позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном. Шаблон может включать обычные символы и символы-шаблоны. При сравнении с шаблоном, его обычные символы должны в точности совпадать с символами, указанными в строке. Символы-шаблоны могут совпадать с произвольными элементами символьной строки.

|     | Символ-шаблон     | Описание                                         | Пример                                                                                                                            |
|:----|-------------------|--------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------|
| 1   | %                 | Любая строка, содержащая ноль или более символов | SELECT * FROM book WHERE author LIKE '%М.%' выполняет поиск и выдает все книги, инициалы авторов которых содержат «М.»            |
| 2   | _ (подчеркивание) | Любой одиночный символ                           | SELECT * FROM book WHERE title LIKE 'Поэм_' выполняет поиск и выдает все книги, названия которых либо «Поэма», либо «Поэмы» и пр. |

Пример 1

Вывести названия книг, начинающихся с буквы «Б».

Запрос:
```
SELECT title 
FROM book
WHERE title LIKE 'Б%';
/* эквивалентное условие 
title LIKE 'б%'
*/
```
Пример 2

Вывести название книг, состоящих ровно из 5 букв.

Запрос:
```
SELECT title FROM book 
WHERE title LIKE "_____"
```

Пример 3

Вывести книги, название которых длиннее 5 символов:

Запрос:
```
SELECT title FROM book 
WHERE title LIKE "______%";
/* эквивалентные условия 
title LIKE "%______"
title LIKE "%______%"
*/
```
Пример 4

Вывести названия книг, которые содержат букву "и" как отдельное слово, если считать, что слова в названии отделяются друг от друга пробелами и не содержат знаков препинания.

 Запрос:
```
SELECT title FROM book 
WHERE   title LIKE "_% и _%" /*отбирает слово И внутри названия */
    OR title LIKE "и _%" /*отбирает слово И в начале названия */
    OR title LIKE "_% и" /*отбирает слово И в конце названия */
    OR title LIKE "и" /* отбирает название, состоящее из одного слова И */
```

Пример 5

Вывести названия книг, которые состоят ровно из одного слова, если считать, что слова в названии отделяются друг от друга пробелами .

 Запрос:
```
SELECT title FROM book 
WHERE title NOT LIKE "% %";   
```

Задание

Вывести название и автора тех книг, название которых состоит из двух и более слов, а инициалы автора содержат букву «С». Считать, что в названии слова отделяются друг от друга пробелами и не содержат знаков препинания, между фамилией автора и инициалами обязателен пробел, инициалы записываются без пробела в формате: буква, точка, буква, точка. Информацию отсортировать по названию книги в алфавитном порядке.

```
SELECT title, author FROM book 
WHERE title LIKE "_% %_"
AND author LIKE "%С.%"
ORDER BY title;  
```
---
# 1.3 Запросы, групповые операции

### Выбор уникальных элементов столбца
Чтобы отобрать уникальные элементы некоторого столбца используется ключевое слово DISTINCT, которое размещается сразу после SELECT.

Пример

Выбрать различных авторов, книги которых хранятся в таблице book.

Запрос:
```
SELECT DISTINCT author
FROM book;
```
Другой способ – использование оператора GROUP BY, который группирует данные при выборке, имеющие одинаковые значения в некотором столбце. Столбец, по которому осуществляется группировка, указывается после GROUP BY .

С помощью GROUP BY можно выбрать уникальные элементы столбца, по которому осуществляется группировка. Результат будет точно такой же как при использовании DISTINCT.

Запрос:
```
SELECT  author
FROM book
GROUP BY author;
```
---

### Выборка данных, групповые функции SUM и COUNT

При группировке над элементами столбца, входящими в группу можно выполнить различные действия, например, просуммировать их или найти количество элементов в группе.

Подробно рассмотрим, как осуществляется группировка данных по некоторому столбцу и вычисления над группой на следующем примере:
```
SELECT author, sum(amount), count(amount)
FROM book
GROUP BY author;
```
1. В таблице book определяются строки, в которых в столбце author одинаковые значения:
Получили 3 различные группы:

- группа I объединяет две записи, у которых в столбце author значение Булгаков М.А.;
- группа II объединяет три записи, у которых в столбце author значение Достоевский Ф.М.;
- группа III объединяет одну запись, у которой в столбце author значение Есенин С.А.
2. Вместо каждой группы в результирующий запрос включается  одна запись. Запись как минимум включает значение столбца, по которому осуществляется группировка (в нашем случае это author):

3. Дальше можно выполнить вычисления над элементами КАЖДОЙ группы в отдельности, например, посчитать общее количество экземпляров книг каждого автора. Для этого используется групповая функция SUM(), а в скобках указывается столбец, по которому нужно выполнить суммирование ( в нашем случае amount):
4. Также можно посчитать, сколько записей относится к группе. Для этого используется функция COUNT(), в скобках можно указать ЛЮБОЙ столбец из группы, если группа не содержит пустых значений (ниже приведен пример, в котором показано, как работает COUNT(), если в группе есть пустые значения):
Пример

Посчитать, сколько экземпляров книг каждого автора хранится на складе.

Запрос:
```
SELECT author, SUM(amount)
FROM book
GROUP BY author;
```
Пример

Посчитать, сколько различных книг каждого автора хранится на складе.

Только для этого примера в таблицу book добавлена запись с пустыми значениями в столбцах amount и price:

Запрос:
```
/* чтобы проверить запрос, добавьте в таблицу строку */
INSERT INTO book (title, author, price, amount) VALUES ('Черный человек','Есенин С.А.', Null, Null);

SELECT author, COUNT(author), COUNT(amount), COUNT(*)
FROM book
GROUP BY author;
```
Из таблицы с результатами запроса видно, что функцию COUNT() можно применять к любому столбцу, в том числе можно использовать и *, если таблица не содержит пустых значений. Если же в столбцах есть значения Null, (для группы по автору Есенин в нашем примере), то

COUNT(*) —  подсчитывает  все записи, относящиеся к группе, в том числе и со значением NULL;
COUNT(имя_столбца) — возвращает количество записей конкретного столбца (только NOT NULL), относящихся к группе.

ВАЖНО.

Если столбец указан в SELECT  БЕЗ применения групповой функции, то он обязательно должен быть указан и вGROUP BY.Иначе получим ошибку.
Между названием функции и скобкой НЕЛЬЗЯ СТАВИТЬ ПРОБЕЛ. Это особенность платформы.

Задание

Посчитать, количество различных книг и количество экземпляров книг каждого автора , хранящихся на складе.  Столбцы назвать Автор, Различных_книг и Количество_экземпляров соответственно.
```
SELECT author AS Автор, COUNT(title) AS Различных_книг, SUM(amount) AS Количество_экземпляров
FROM book
GROUP BY author;
```
---
### Выборка данных, групповые функции MIN, MAX и AVG
К групповым функциям SQL относятся: MIN(), MAX() и AVG(), которые вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе.

Пример

Вывести минимальную цену книги каждого автора

Запрос:
```
SELECT author, MIN(price) AS min_price
FROM book
GROUP BY author;
```
Задание

Вывести фамилию и инициалы автора, минимальную, максимальную и среднюю цену книг каждого автора . Вычисляемые столбцы назвать Минимальная_цена, Максимальная_цена и Средняя_цена соответственно.
```
SELECT author, MIN(price) AS Минимальная_цена, MAX(price) AS Максимальная_цена, AVG(price) AS Средняя_цена
FROM book
GROUP BY author;
```
---
### Выборка данных c вычислением, групповые функции
В качестве аргумента групповых функций  SQL может использоваться не только столбец, но и любое допустимое в SQL арифметическое выражение.

Пример

Вывести суммарную стоимость книг каждого автора.

Запрос:
```
SELECT author, SUM(price * amount) AS Стоимость
FROM book
GROUP BY author;
```

Групповые функции могут быть элементами выражений. Например, при вычислении средней стоимости книг каждого автора на предыдущем шаге получились значения с шестью знаками после запятой. А поскольку это деньги, значения нужно округлить до 2 знаков после запятой.

 Пример

Найти среднюю цену книг каждого автора.

Запрос:
```
SELECT author, ROUND(AVG(price),2) AS Средняя_цена
FROM book
GROUP BY author;
```
Задание

Для каждого автора вычислить суммарную стоимость книг S (имя столбца Стоимость), а также вычислить налог на добавленную стоимость  для полученных сумм (имя столбца НДС ) , который включен в стоимость и составляет k = 18%,  а также стоимость книг  (Стоимость_без_НДС) без него. Значения округлить до двух знаков после запятой. В запросе для расчета НДС(tax)  и Стоимости без НДС(S_without_tax) использовать следующие формулы:

```
SELECT author, ROUND(SUM(price*amount),2) AS Стоимость,
ROUND((SUM(price*amount)*0.18)/1.18,2) AS НДС,
ROUND((SUM(price*amount))/1.18,2) AS Стоимость_без_НДС
FROM book
GROUP BY author;
```
---
### Вычисления по таблице целиком
Групповые функции позволяют вычислять итоговые значения по всей таблице. Например, можно посчитать общее количество книг на складе, вычислить суммарную стоимость и пр. Для этого после ключевого слова SELECT указывается групповая функция для выражения или имени столбца, а ключевые слова GROUP BY опускаются.

Пример

Посчитать количество экземпляров книг на складе.

Запрос:
```
SELECT SUM(amount) AS Количество
FROM book;
```
Результатом таких запросов является единственная строка с вычисленными по таблице значениями.

 Пример

Посчитать общее количество экземпляров книг на складе и их стоимость .

Запрос:
```
SELECT SUM(amount) AS Количество, 
    SUM(price * amount) AS Стоимость
FROM book;
```
Задание
Вывести цену самой дешевой книги, цену самой дорогой и среднюю цену уникальных книг на складе. Названия столбцов Минимальная_цена, Максимальная_цена, Средняя_цена соответственно. Среднюю цену округлить до двух знаков после запятой.

Пояснение. В задании нужно посчитать среднюю цену уникальных книг на складе, а не среднюю цену всех экземпляров книг.
```
SELECT MIN(price) AS Минимальная_цена,
      MAX(price) AS Максимальная_цена, 
      ROUND(AVG(price),2) AS Средняя_цена
FROM book;
```
---
### Выборка данных по условию, групповые функции

В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после WHERE. В запросах с групповыми функциями вместо WHERE используется ключевое слово HAVING , которое размещается после оператора GROUP BY.

Пример

Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000.

Запрос:
```
SELECT author,
    MIN(price) AS Минимальная_цена, 
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000; 
```
Также в запросах с группировкой можно сортировать данные.

 Пример

Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000. Результат вывести по убыванию минимальной цены.

Запрос:
```
SELECT author,
    MIN(price) AS Минимальная_цена, 
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000 
ORDER BY Минимальная_цена DESC;
```
Задание

Вычислить среднюю цену и суммарную стоимость тех книг, количество экземпляров которых принадлежит интервалу от 5 до 14, включительно. Столбцы назвать Средняя_цена и Стоимость, значения округлить до 2-х знаков после запятой.
```
SELECT 
    ROUND(AVG(price),2) AS Средняя_цена, 
    ROUND(SUM(price*amount),2) AS Стоимость
FROM book
WHERE amount BETWEEN 5 AND 14;
```
Пояснение
Если в запросе с групповыми функциями отсутствует GROUP BY, то для отбора записей используется ключевое слово WHERE.

---
### Выборка данных по условию, групповые функции, WHERE и HAVING

WHERE и HAVING могут использоваться в одном запросе. При этом необходимо учитывать порядок выполнения  SQL запроса на выборку на СЕРВЕРЕ:

- FROM
- WHERE
- GROUP BY
- HAVING
- SELECT
- ORDER BY

Сначала определяется таблица, из которой выбираются данные (FROM), затем из этой таблицы отбираются записи в соответствии с условием  WHERE, выбранные данные агрегируются (GROUP BY),  из агрегированных записей выбираются те, которые удовлетворяют условию после HAVING. Потом формируются данные результирующей выборки, как это указано после SELECT ( вычисляются выражения, присваиваются имена и пр. ). Результирующая выборка сортируется, как указано после ORDER BY.

Важно! Порядок ВЫПОЛНЕНИЯ запросов - это не порядок ЗАПИСИ ключевых слов в запросе на выборку. Порядок записи (синтаксис запроса) остается таким же, как рассматривался ранее в курсе. Порядок ВЫПОЛНЕНИЯ  нужен для того, чтобы понять, почему, например, в WHERE нельзя использовать имена выражений из SELECT. Просто SELECT выполняется компилятором позже, чем WHERE, поэтому ему неизвестно, какое там выражение написано.

Пример

Вывести максимальную и минимальную цену книг каждого автора, кроме Есенина, количество экземпляров книг которого больше 10. 
```
SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
WHERE author <> 'Есенин С.А.'
GROUP BY author
HAVING SUM(amount) > 10;
```

Другим способом решения примера является запрос:
```
SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(amount) > 10 AND author <> 'Есенин С.А.';
```
Не смотря на то что результат будет одинаковым, так делать не рекомендуется. «Потому что как написано - запрос сначала выбирает всех авторов, потом выводит данные, рассчитывая минимальное и максимальное значение цены для каждого, и только после всего убирает Есенина. Можно убрать Есенина в данном случае раньше и не использовать ресурсы базы для расчета его минимального и максимального значения, как это сделано в первом варианте. На небольшой базе быстродействия не ощутить, но если выполнять такое на продуктивной, то второй вариант значительно проигрывает...»

Задание

Посчитать стоимость всех экземпляров каждого автора без учета книг «Идиот» и «Белая гвардия». В результат включить только тех авторов, у которых суммарная стоимость книг (без учета книг «Идиот» и «Белая гвардия») более 5000 руб. Вычисляемый столбец назвать Стоимость. Результат отсортировать по убыванию стоимости.
```
SELECT author,
    SUM(price * amount) AS Стоимость
FROM book
WHERE title NOT IN ('Идиот', 'Белая гвардия')
GROUP BY author
HAVING SUM(price * amount) > 5000
ORDER BY SUM(price * amount) DESC;
```
---
# 1.4 Вложенные запросы

SQL позволяет создавать вложенные запросы. Вложенный запрос (подзапрос, внутренний запрос) – это запрос внутри другого запроса SQL.

Вложенный запрос используется для выборки данных, которые будут использоваться в условии отбора записей основного запроса. Его применяют для:

- сравнения выражения с результатом вложенного запроса;
- определения того, включено ли выражение в результаты вложенного запроса;
- проверки того, выбирает ли запрос определенные строки.

Вложенный запрос имеет следующие компоненты:

- ключевое слово SELECT после которого указываются имена столбцов или выражения (чаще всего список содержит один элемент) ;
- ключевое слово FROM и имя таблицы, из которой выбираются данные;
- необязательное предложение WHERE;
- необязательное предложение GROUP BY:
- необязательное предложение HAVING.

 Вложенные запросы могут включаться в WHERE или HAVING так (в квадратных скобках указаны необязательные элементы, через | – один из элементов):

- WHERE | HAVING выражение оператор_сравнения (вложенный запрос);
- WHERE | HAVING выражение, включающее вложенный запрос;
- WHERE | HAVING выражение [NOT] IN (вложенный запрос);
- WHERE | HAVING выражение  оператор_сравнения  ANY | ALL (вложенный запрос).

Также вложенные запросы могут вставляться в основной запрос после ключевого слова SELECT.

---

### Вложенный запрос, возвращающий одно значение

Вложенный запрос, возвращающий одно значение, может использоваться в условии отбора записей WHERE как обычное значение совместно с операциями =, <>, >=, <=, >, <.

Пример

Вывести информацию о самых дешевых книгах, хранящихся на складе.

Для реализации этого запроса нам необходимо получить минимальную цену из столбца price таблицы book, а затем вывести информацию о тех книгах, цена которых  равна минимальной. Первая часть  – поиск  минимума – реализуется вложенным запросом.

Запрос:
```
SELECT title, author, price, amount
FROM book
WHERE price = (
         SELECT MIN(price) 
         FROM book
      );
```
Вложенный запрос определяет минимальную цену книг во всей таблице (это 460.00), а затем в основном запросе для каждой записи проверяется, равна ли цена минимальному значению, если равна, информация о книге включается в результирующую таблицу запроса.

Рекомендация.
При использовании вложенного запроса рекомендуется сначала проверить, правильно ли он работает (занести текст запроса в окно кода и нажать черную кнопку Запустить), если выдается верный результат – использовать код в качестве вложенного запроса.

Задание

Вывести информацию (автора, название и цену) о  книгах, цены которых меньше или равны средней цене книг на складе. Информацию вывести в отсортированном по убыванию цены виде. Среднее вычислить как среднее по цене книги.

```
SELECT author, title, price
FROM book
WHERE price <= (
         SELECT AVG(price) 
         FROM book
      )
ORDER BY price DESC;
```
---

### Использование вложенного запроса в выражении

Вложенный запрос, возвращающий одно значение, может использоваться в выражениях как обычный операнд, например, к нему 
можно что-то прибавить, вычесть и пр.

Пример

Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе
более чем на 3. То есть нужно вывести и те книги, количество экземпляров которых меньше среднего на 3, или больше среднего на 3.

Запрос:
```
SELECT title, author, amount 
FROM book
WHERE ABS(amount - (SELECT AVG(amount) FROM book)) >3;
```
Задание

Вывести информацию (автора, название и цену) о тех книгах, цены которых превышают минимальную цену книги на складе
не более чем на 150 рублей в отсортированном по возрастанию цены виде.
```
SELECT author, title, price 
FROM book
WHERE price <= (150 + (SELECT MIN(price) FROM book))
ORDER BY price;
```
---

### Вложенный запрос, оператор IN

Вложенный запрос может возвращать несколько значений одного столбца.  Тогда его можно использовать в разделе WHERE совместно с оператором IN.

WHERE имя_столбца IN (вложенный запрос, возвращающий один столбец)
Оператор IN определяет, совпадает ли значение столбца с одним из значений, содержащихся во вложенном запросе. При этом логическое выражение после WHERE получает значение истина. Оператор NOT IN выполняет обратное действие – выражение истинно, если значение столбца не содержится во вложенном запросе.

Пример

Вывести информацию о книгах тех авторов, общее количество экземпляров книг которых не менее 12.

Запрос:
```
SELECT title, author, amount, price
FROM book
WHERE author IN (
        SELECT author 
        FROM book 
        GROUP BY author 
        HAVING SUM(amount) >= 12
      );
```
Вложенный запрос отбирает двух авторов (Достоевского и Есенина). А в основном запросе для каждой записи таблицы book 
проверяется, входит ли автор книги в отобранный список, если входит - информация о книге включается в запрос.

Задание

Вывести информацию (автора, книгу и количество) о тех книгах, количество экземпляров которых в таблице book не дублируется.
```
SELECT author, title, amount
FROM book
WHERE amount IN (
        SELECT amount 
        FROM book 
        GROUP BY amount 
        HAVING count(amount) = 1
      );
```
Во вложенном запросе мы группируем элементы нашей таблицы по количеству книг (GROUP BY amount), т.е. например, 
"Мастер и Маргарита" и "Братья Карамазовы" попадают в одну группу, т.к. и тех и тех по 3 штуки. Потом c помощью функции
COUNT(amount) считаем сколько получилось элементов в каждой группе. Например, в группе "5" - один  элемент. 
Нам нужны те группы, которые состоят только из одного элемента, т.е. HAVING COUNT(amount)=1. Список этих групп 
и формируется в общем запросе: SELECT amount. Во внешнем запросе мы из таблицы book выбираем те строчки, в которых 
количество amount совпадает с какой-либо группой, получившейся во внутреннем запросе. И выводим различную информацию
из этих строчек: author, title, amount.

---

### Вложенный запрос, операторы ANY и ALL

Вложенный запрос, возвращающий несколько значений одного столбца, можно использовать для отбора записей с помощью операторов ANY и ALL совместно с операциями отношения (=, <>, <=, >=, <, >).

Операторы ANY и ALL используются  в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца. При этом тип данных столбца, возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения), с которым происходит сравнение.

При использовании оператора ANY в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса. Как работает оператор ANY:
- amount > ANY (10, 12) эквивалентно amount > 10
- amount < ANY (10, 12) эквивалентно amount < 12
- amount = ANY (10, 12) эквивалентно (amount = 10) OR (amount = 12), а также amount IN  (10,12)
- amount <> ANY (10, 12) вернет все записи с любым значением amount, включая 10 и 12

При использовании оператора ALL в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно для всех элементов результирующего запроса. Как работает оператор ALL:

- amount > ALL (10, 12) эквивалентно amount > 12
- amount < ALL (10, 12) эквивалентно amount < 10
- amount = ALL (10, 12) не вернет ни одной записи, так как эквивалентно (amount = 10) AND (amount = 12)
- amount <> ALL (10, 12) вернет все записи кроме тех,  в которыхamount равно 10 или 12

Важно! Операторы ALL и ANY можно использовать только с вложенными запросами. В примерах выше (10, 12) приводится как результат вложенного запроса просто для того, чтобы показать как эти операторы работают. В запросах так записывать нельзя.

Пример

Вывести информацию о тех книгах, количество которых меньше самого маленького среднего количества книг каждого автора.

Запрос:
```
SELECT title, author, amount, price
FROM book
WHERE amount < ALL (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      );
```
Пояснение
1. Вложенный запрос

SELECT AVG(amount) 
        FROM book 
        GROUP BY author
отбирает следующие записи:

| AVG(amount) |
|:------------|
| 4.0000      |
| 7.6667      |
| 15.0000     |

2. Условие отбора в основном запросе
```
amount < ALL (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      )
```
можно переписать (если заменить вложенный запрос списком отобранных значений):

amount < ALL ( 4.0000, 7.6667, 15.0000)
что в соответствии с определением ALL, это значит, что подходят все amount меньшие 4.000.

Таким образом, наш запрос отобрал все книги книги Мастер и Маргарита и Братья Карамазовы, количество которых равно 3. 

Пример

Вывести информацию о тех книгах, количество которых меньше самого большого среднего количества книг каждого автора.

Запрос:
```
SELECT title, author, amount, price
FROM book
WHERE amount < ANY (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      );
```
Результат:

| title              | author           | amount | price  |
|:-------------------|:-----------------|:-------|:------:|
| Мастер и Маргарита | Булгаков М.А.    | 3      | 670.99 |
| Белая гвардия      | Булгаков М.А.    | 5      | 540.50 |
| Идиот              | Достоевский Ф.М. | 10     | 460.00 |
| Братья Карамазовы  | Достоевский Ф.М. | 3      | 799.01 |
| Игрок              | Достоевский Ф.М. | 10     | 480.50 |

Пояснение

В этом примере amount < ANY ( 4.0000, 7.6667, 15.0000)  означает, что подходят amount меньше самого большого значения из списка.

Задание

Вывести информацию о книгах(автор, название, цена), цена которых меньше самой большой из минимальных цен, вычисленных для каждого автора.
```
SELECT author, title, price
FROM book
WHERE price < ANY (
        SELECT MIN(price) 
        FROM book 
        GROUP BY author 
      );
```
---

### Вложенный запрос после SELECT

Вложенный запрос может располагаться после ключевого слова SELECT. В этом случае результат выполнения запроса выводится в отдельном столбце результирующей таблицы. При этом результатом запроса может быть только одно значение, тогда оно будет повторяться во всех строках. Также вложенный запрос может использоваться в выражениях.

Пример

Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3,  а также указать среднее значение количества экземпляров книг.

Запрос:
```
SELECT title, author, amount, 
    (
     SELECT AVG(amount) 
     FROM book
    ) AS Среднее_количество 
FROM book
WHERE abs(amount - (SELECT AVG(amount) FROM book)) >3;
```
Пояснение

В запросе используется функция модуля, которая позволяет учесть, что количество может отличаться от среднего как в большую, так и в меньшую сторону.

| title                 | author           | amount | Среднее_количество |
|:----------------------|------------------|--------|-------------------:|
| Мастер и Маргарита    | Булгаков М.А.    | 3      |             7.6667 |
| Братья Карамазовы     | Достоевский Ф.М. | 3      |             7.6667 |
| Стихотворения и поэмы | Есенин С.А.      | 15     |             7.6667 |

Во вложенном запросе вычисляется среднее количество экземпляров книг на складе. Этот запрос используется и в условии отбора, и для создания столбца Среднее_количество в результирующей таблице запроса. Значения  столбца одинаковы во всех строках, поскольку  вложенный запрос возвращает одно значение.

Среднее количество в виде дробного числа выглядит не очень правильно. Полученное значение можно округлить "вниз" - до ближайшего меньшего целого.

Запрос:
```
SELECT title, author, amount, 
      FLOOR((SELECT AVG(amount) FROM book)) AS Среднее_количество 
FROM book
WHERE ABS(amount - (SELECT AVG(amount) FROM book)) >3;
```
Результат:

| title                 | author           | amount | Среднее_количество |
|:----------------------|------------------|--------|-------------------:|
| Мастер и Маргарита    | Булгаков М.А.    | 3      |                  7 |
| Братья Карамазовы     | Достоевский Ф.М. | 3      |                  7 |
| Стихотворения и поэмы | Есенин С.А.      | 15     |                  7 |

Задание

Посчитать сколько и каких экземпляров книг нужно заказать поставщикам, чтобы на складе стало одинаковое количество экземпляров каждой книги, равное значению самого большего количества экземпляров одной книги на складе. Вывести название книги, ее автора, текущее количество экземпляров на складе и количество заказываемых экземпляров книг. Последнему столбцу присвоить имя Заказ. В результат не включать книги, которые заказывать не нужно.
```
SELECT title, author, amount, 
      (SELECT MAX(amount)  FROM book) - amount AS Заказ
FROM book
WHERE amount < (SELECT MAX(amount) FROM book);
```
---

# 1.5 Запросы корректировки данных

### Создание пустой таблицы

Создание таблицы осуществляется с помощью запроса CREATE, подробно рассмотренного в первом уроке модуля.

Задание

Создать таблицу поставка (supply), которая имеет ту же структуру, что и таблиц book.

| Поле              | Тип, описание                  | 
|---|--------------------------------|
| supply_id               | INT PRIMARY KEY AUTO_INCREMENT | 
| title              | VARCHAR(50)                    | 
| author              | VARCHAR(30)                    | 
| price              | DECIMAL(8, 2)                  | 
| amount            | INT                            | 

### Добавление записей в таблицу

Добавление одной записи в таблицу осуществляется с помощью запроса INSERT, подробно рассмотренного в первом уроке. Запросы обязательно разделять точкой с запятой.

Допускается вставка нескольких записей одновременно, для этого используется SQL запрос следующего вида:
```
INSERT INTO имя_таблицы(столбец_1, столбец_2, ..., столбец_N)
VALUES
    (значение_1_1, значение_1_2, ..., значение_1_N),
    (значение_2_1, значение_2_2, ..., значение_2_N),
    ...
    (значение_M_1, значение_M_2, ..., значение_M_N);
```
Например, чтобы добавить в таблицу book две новые записи используется запрос:
```
INSERT INTO book (title, author, price, amount) 
VALUES 
    ('Война и мир','Толстой Л.Н.', 1070.20, 2),
    ('Анна Каренина', 'Толстой Л.Н.', 599.90, 3);
```

Задание

Занесите в таблицу supply четыре записи, чтобы получилась следующая таблица:

|| supply_id |	title|	author|	price| 	amount |
|-----------|---|---|---|---------|---|
| 1         |	Лирика|	Пастернак Б.Л.|	518.99	| 2       |
| 2	        |Черный человек| 	Есенин С.А.|	570.20| 	6      |
| 3         |	Белая гвардия	|Булгаков М.А.|	540.50| 	7      |
| 4         |	Идиот|	Достоевский Ф.М.|	360.80| 	3      |
```
INSERT INTO supply (title, author, price, amount) 
VALUES 
("Лирика", "Пастернак Б.Л.", 518.99, 2),
("Черный человек", "Есенин С.А.", 570.20, 6),
("Белая гвардия", "Булгаков М.А.", 540.50, 7),
("Идиот", "Достоевский Ф.М.", 360.80, 3);
```

### Добавление записей из другой таблицы

С помощью запроса на добавление можно не только добавить в таблицу конкретные значения (список VALUES), но и записи из другой таблицы, отобранные с помощью запроса на выборку.  В этом случае вместо раздела VALUES записывается запрос на выборку, начинающийся с SELECT.  В нем можно использовать WHERE, GROUP BY, ORDER BY.

Правила соответствия между полями таблицы и вставляемыми значениями из запроса:

количество полей в таблице и количество полей в запросе должны совпадать;
должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый столбец запроса должен относиться к первому столбцу в списке столбцов таблицы, второй – ко второму столбцу и т.д.
 типы столбцов запроса должны быть совместимы с типами данных соответствующих столбцов таблицы ( целое число можно занести в поле типа DECIMAL, обратная операция – недопустима).
Пример

Занести все книги из таблицы supply в таблицу book.

Запрос:
```
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply;

SELECT * FROM book;
```
С помощью этого запроса в таблицу book включены все книги из supply, даже те, которые в book уже есть («Белая гвардия» и «Идиот»). В результате в таблице одна и та же книга, например «Белая гвардия», имеет код 2 и 8. Для реляционной модели это нежелательная ситуация. Устранить эту проблему можно с помощью вложенных запросов, которые будут рассмотрены в следующем шаге.
Задание

Добавить из таблицы supply в таблицу book, все книги, кроме книг, написанных Булгаковым М.А. и Достоевским Ф.М.

```
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
WHERE author NOT IN ("Булгаков М.А.", "Достоевский Ф.М.")
FROM supply;

SELECT * FROM book;
```
---

### Добавление записей, вложенные запросы

В запросах на добавление можно использовать вложенные запросы.

Пример

Занести из таблицы supply в таблицу book только те книги, названия которых отсутствуют в таблице book.

Запрос:
```
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply
WHERE title NOT IN (
        SELECT title 
        FROM book
      );

SELECT * FROM book;
```

Вложенным запросом отбираются все названия книг, которые есть в таблице book. Основным запросом SELECT из таблицы supply выбираются книги, названия которых нет в результате вложенного запроса. Отобранные записи добавляются в конец таблицы bookзапросом на добавление INSERT.

Задание

Занести из таблицы supply в таблицу book только те книги, авторов которых нет в  book.

```
INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply
WHERE author NOT IN (
        SELECT author 
        FROM book
      );

SELECT * FROM book;
```
---

### Запросы на обновление

Под обновлением данных подразумевается изменение значений в существующих записях таблицы. При этом возможно как изменение значений полей в группе строк (даже всех строк таблицы), так и правка значения поля отдельной строки.

Изменение записей в таблице реализуется с помощью запроса UPDATE. Простейший запрос на  обновление выглядит так:

UPDATE таблица SET поле = выражение
где 
таблица – имя таблицы, в которой будут проводиться изменения;
поле – поле таблицы, в которое будет внесено изменение;
выражение – выражение,  значение которого будет занесено в поле.

Пример

Уменьшить на 30% цену книг в таблице book.

Запрос:
```
UPDATE book 
SET price = 0.7 * price;

SELECT * FROM book;
```

С помощью запросов на обновление можно изменять не все записи в таблице (как в предыдущем запросе), а только часть из них. Для этого в запрос включается ключевое слово WHERE, после которого указывается условие отбора строк для изменения.

Пример

Уменьшить на 30% цену тех книг в таблице book, количество которых меньше 5.

Запрос:
```
UPDATE book 
SET price = 0.7 * price 
WHERE amount < 5;

SELECT * FROM book;
```

Задание

Уменьшить на 10% цену тех книг в таблице book, количество которых принадлежит интервалу от 5 до 10, включая границы.
```
UPDATE book 
SET price = 0.9 * price 
WHERE amount BETWEEN 5 AND 10;

SELECT * FROM book;
```
---

### Запросы на обновление нескольких столбцов

Запросом UPDATE можно обновлять значения нескольких столбцов одновременно. В этом случае простейший запрос будет выглядеть так:
```
UPDATE таблица SET поле1 = выражение1, поле2 = выражение2
```
На складе, кроме хранения и получения книг, выполняется их оптовая продажа. Для реализации этого действия включим дополнительный столбец buy  в таблицу book:

В столбце buy покупатель указывает количество книг, которые он хочет приобрести. Для каждой книги, выбранной покупателем, необходимо уменьшить ее количество на складе на указанное в столбцеbuy количество, а в столбец buy занести 0.

Запрос:
```
UPDATE book 
SET amount = amount - buy,
    buy = 0;

SELECT * FROM book;
```
Как видно из таблицы, без проверки данных, которые занесены в столбец,  нельзя запускать запрос на обновление (может получиться отрицательное значение количества).

Задание

В таблице book необходимо скорректировать значение для покупателя в столбце buy таким образом, чтобы оно не превышало количество экземпляров книг, указанных в столбце amount. А цену тех книг, которые покупатель не заказывал, снизить на 10%.
```
UPDATE book 
SET buy = IF(buy > amount, amount, buy), price = IF(buy = 0, price * 0.9, price);

SELECT * FROM book;
```
---

### Запросы на обновление нескольких таблиц

В запросах на обновление можно использовать несколько таблиц, но тогда

- для столбцов, имеющих одинаковые имена, необходимо указывать имя таблицы, к которой они относятся, например, book.price – столбец price из таблицы book, supply.price – столбец price из таблицы supply;
- все таблицы, используемые в запросе, нужно перечислить после ключевого слова UPDATE;
- в запросе обязательно условие WHERE, в котором указывается условие при котором обновляются данные.

Пример

Если в таблице supply  есть те же книги, что и в таблице book, добавлять эти книги в таблицу book не имеет смысла. Необходимо увеличить их количество на значение столбца amountтаблицы supply.

Запрос:
```
UPDATE book, supply 
SET book.amount = book.amount + supply.amount
WHERE book.title = supply.title AND book.author = supply.author;

SELECT * FROM book;
```
В этом запросе увеличилось количество двух книг: «Белая гвардия», которая в supply имеет ту же цену, и «Идиот», но цена этой книги в таблицах book и supply отличается. Для этой книги нужно пересчитать цену.

Задание

Для тех книг в таблице book, которые есть в таблице supply, не только увеличить их количество в таблице book ( увеличить их количество на значение столбца amountтаблицы supply), но и пересчитать их цену (для каждой книги найти сумму цен из таблиц book и supply и разделить на 2).
```
UPDATE book, supply 
SET book.amount = book.amount + supply.amount,
book.price = (book.price + supply.price)/2
WHERE book.title = supply.title AND book.author = supply.author;

SELECT * FROM book;
```
---

### Запросы на удаление

Запросы корректировки данных позволяют удалить одну или несколько записей из  таблицы. Простейший запрос на удаление имеет вид:
```
DELETE FROM таблица;
```
Этот запрос удаляет все записи из указанной после FROM таблицы.

Пример

После того, как информация о книгах из таблицы supply перенесена в book , необходимо очистить таблицу  supply.

Запрос:
```
DELETE FROM supply;

SELECT * FROM supply;
```
Из таблицы удалены все записи. Запрос на выборку отобрал 0 записей.

Запрос на удаления позволяет удалить не все записи таблицы, а только те, которые удовлетворяют условию, указанному после ключевого слова WHERE:
```
DELETE FROM таблица
WHERE условие;
```
Пример

Удалить из таблицы supply все книги, названия которых есть в таблице book.

Запрос:
```
DELETE FROM supply 
WHERE title IN (
        SELECT title 
        FROM book
      );


SELECT * FROM supply;
```

Из таблицы supply удалены две записи о книгах «Белая гвардия» и «Идиот».

Задание

Удалить из таблицы supply книги тех авторов, общее количество экземпляров книг которых в таблице book превышает 10.
```
DELETE FROM supply 
WHERE author IN (
        SELECT author 
        FROM book 
        GROUP BY author 
        HAVING SUM(amount) > 10
      );

SELECT * FROM supply;
```
---

### Запросы на создание таблицы

Новая таблица может быть создана на основе данных из другой таблицы. Для этого используется запрос SELECT, результирующая таблица которого и будет новой таблицей базы данных. При этом имена столбцов запроса становятся именами столбцов новой таблицы. Запрос на создание новой таблицы имеет вид:
```
CREATE TABLE имя_таблицы AS
SELECT ...
```
Пример

Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице book меньше 4. Для всех книг указать одинаковое количество экземпляров 5.

Запрос:
```
CREATE TABLE ordering AS
SELECT author, title, 5 AS amount
FROM book
WHERE amount < 4;

SELECT * FROM ordering;
```
При создании таблицы можно использовать вложенные запросы как после SELECT, так и после WHERE.

Пример

Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице book меньше 4. Для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице book.

Запрос:
```
CREATE TABLE ordering AS
SELECT author, title, 
   (
    SELECT ROUND(AVG(amount)) 
    FROM book
   ) AS amount
FROM book
WHERE amount < 4;

SELECT * FROM ordering;
```

Задание

Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице
book меньше среднего количества экземпляров книг в таблице book. В таблицу включить столбец   amount, в котором для всех
книг указать одинаковое значение - среднее количество экземпляров книг в таблице book.

```
CREATE TABLE ordering AS
SELECT author, title, 
   (
    SELECT ROUND(AVG(amount)) 
    FROM book
   ) AS amount
FROM book
WHERE amount < (
    SELECT ROUND(AVG(amount)) 
    FROM book
   );

SELECT * FROM ordering;
```
---

# 1.6 Таблица "Командировки", запросы на выборку

 Задание

Вывести из таблицы trip информацию о командировках тех сотрудников, фамилия которых заканчивается на букву «а»,
в отсортированном по убыванию даты последнего дня командировки виде. В результат включить столбцы name, city, per_diem,
date_first, date_last.
```
SELECT name, city, per_diem, date_first, date_last
FROM trip
WHERE name LIKE "%а _._."
ORDER BY date_last DESC;
```
Задание

Вывести в алфавитном порядке фамилии и инициалы тех сотрудников, которые были в командировке в Москве.
```
SELECT name
FROM trip
WHERE city="Москва"
GROUP BY name
ORDER BY name;
```
Задание

Для каждого города посчитать, сколько раз сотрудники в нем были.  Информацию вывести в отсортированном в алфавитном 
порядке по названию городов. Вычисляемый столбец назвать Количество. 
```
SELECT city, count(city) AS Количество
FROM trip
GROUP BY city
ORDER BY city;
```

### Оператор LIMIT

Для ограничения вывода записей в SQL используется оператор LIMIT , после которого указывается количество строк.  Результирующая таблица будет иметь количество строк не более указанного после LIMIT. LIMIT размещается после раздела ORDER BY.

Как правило, этот оператор используется, чтобы отобрать заданное количество отсортированных строк результата запроса. 

Пример

Вывести информацию о первой  командировке из таблицы trip. "Первой" считать командировку с самой ранней датой начала.

Запрос:
```
SELECT *
FROM trip
ORDER BY  date_first
LIMIT 1;
```
Важно. Оператор LIMIT нужно использовать очень осторожно. Например, если бы в таблице trip было несколько командировок
с одинаковой датой начала, этот запрос работал бы НЕВЕРНО. Это связано с тем, что заранее не известно точное значение 
таких командировок.

Задание

Вывести два города, в которых чаще всего были в командировках сотрудники. Вычисляемый столбец назвать Количество.

```
SELECT city, count(city) AS Количество
FROM trip
GROUP BY city
ORDER BY Количество
LIMIT 2;
```

Задание
Вывести информацию о командировках во все города кроме Москвы и Санкт-Петербурга (фамилии и инициалы сотрудников, город ,  длительность командировки в днях, при этом первый и последний день относится к периоду командировки). Последний столбец назвать Длительность. Информацию вывести в упорядоченном по убыванию длительности поездки, а потом по убыванию названий городов (в обратном алфавитном порядке).

Немного теории
Для вычитания двух дат используется функция DATEDIFF(дата_1, дата_2), результатом которой является количество дней между дата_1 и дата_2. Например,
```
DATEDIFF('2020-04-01', '2020-03-28')=4

DATEDIFF('2020-05-09','2020-05-01')=8

DATEDIFF(date_last, date_first)
```
Пояснение

Увеличьте разницу на 1, чтобы включить первый день командировки.

```
SELECT name, city, DATEDIFF(date_last, date_first)+1 AS Длительность
FROM trip
WHERE city NOT IN ("Москва", "Санкт-Петербург")
ORDER BY Длительность DESC, city DESC;
```

Задание

Вывести информацию о командировках сотрудника(ов), которые были самыми короткими по времени. В результат включить 
столбцы name, city, date_first, date_last.

```
SELECT name, city, date_first, date_last
FROM trip
WHERE DATEDIFF(date_last, date_first) = (SELECT MIN(DATEDIFF(date_last, date_first)) FROM trip);
```

Задание
Вывести информацию о командировках, начало и конец которых относятся к одному месяцу (год может быть любой). В результат включить столбцы name, city, date_first, date_last. Строки отсортировать сначала  в алфавитном порядке по названию города, а затем по фамилии сотрудника .

Немного теории

Для того, чтобы выделить номер месяца из даты используется функция MONTH(дата).

Например, MONTH('2020-04-12') = 4.

Если определяется месяц для  значений столбца date_first, то используется запись MONTH(date_first)

```
SELECT name, city, date_first, date_last
FROM trip
WHERE MONTH(date_last) = MONTH(date_first) 
ORDER BY city, name;
```
Задание

Вывести название месяца и количество командировок для каждого месяца. Считаем, что командировка относится к некоторому
месяцу, если она началась в этом месяце. Информацию вывести сначала в отсортированном по убыванию количества, а потом 
в алфавитном порядке по названию месяца виде. Название столбцов – Месяц и Количество.

Немного теории

Для того, чтобы выделить название месяца из даты используется функция MONTHNAME(дата), которая возвращает название
месяца на английском языке для указанной даты. Например, MONTHNAME('2020-04-12')='April'.
Если группировка осуществляется по вычисляемому столбцу (в данном случае «вычисляется» название месяца), то после 
GROUP BY можно указать как вычисляемое выражение, так и имя столбца, заданное с помощью AS. Важно отметить, что последний вариант (указать имя столбца)  нарушает стандарт по порядку выполнения запросов, но иногда может встречаться на реальных платформах.

```
SELECT MONTHNAME(date_first) AS Месяц, COUNT(MONTHNAME(date_first)) AS Количество
FROM trip
GROUP BY 1
ORDER BY 2 DESC, 1;
```
---
Задание

Вывести сумму суточных (произведение количества дней командировки и размера суточных) для командировок, первый день 
которых пришелся на февраль или март 2020 года. Значение суточных для каждой командировки занесено в столбец per_diem. Вывести фамилию и инициалы сотрудника, город, первый день командировки и сумму суточных. Последний столбец назвать Сумма. Информацию отсортировать сначала  в алфавитном порядке по фамилиям сотрудников, а затем по убыванию суммы суточных.

1. В SQL есть функции, которые позволяют выделить часть даты: день(DAY()), месяц (MONTH()), год(YEAR()) . Например:
```
DAY('2020-02-01') = 1
MONTH('2020-02-01') = 2
YEAR('2020-02-01') = 2020
```
2. Количество дней командировки вычисляется как разница между датами последнего и первого дня командировки плюс 1.

```
SELECT name, city, date_first, per_diem * (DATEDIFF(date_last, date_first) + 1) AS  Сумма
FROM trip
WHERE MONTH(date_first) BETWEEN 2 AND 3 AND YEAR(date_first) = 2020
ORDER BY 1, 2 DESC;
```

Задание
Вывести фамилию с инициалами и общую сумму суточных, полученных за все командировки для тех сотрудников, которые были в командировках больше чем 3 раза, в отсортированном по убыванию сумм суточных виде. Последний столбец назвать Сумма.
```
SELECT name, SUM((DATEDIFF(date_last, date_first) + 1) * per_diem) AS Сумма
FROM trip
GROUP BY name
HAVING COUNT(date_first) > 3
ORDER BY 2 DESC;
```
---
## 1.7 Таблица "Нарушения ПДД", запросы корректировки

Задание

Создать таблицу fine следующей структуры:

| Поле           | 	Описание                                                                      |
|----------------|--------------------------------------------------------------------------------|
| fine_id        | 	ключевой столбец целого типа с автоматическим увеличением значения ключа на 1 |
| name	          | строка длиной 30                                                               |
| number_plate   | 	строка длиной 6                                                               |
| violation	     | строка длиной 50                                                               |
| sum_fine	      | вещественное число, максимальная длина 8, количество знаков после запятой 2   | 
| date_violation | 	дата                                                                          |
| date_payment   | 	дата                                                                          |

```
CREATE TABLE fine(
    fine_id INT PRIMARY KEY AUTO_INCREMENT, 
    name VARCHAR(30),
    number_plate VARCHAR(6),
    violation VARCHAR(50),
    sum_fine DECIMAL(8,2),
    ate_violation DATE,
    date_payment DATE
);
```
---
Задание

В таблицу fine первые 5 строк уже занесены. Добавить в таблицу записи с ключевыми значениями 6, 7, 8.
```
INSERT INTO fine (name, number_plate, violation, sum_fine, date_violation, date_payment) 
VALUES 
("Баранов П.Е.", "Р523ВТ", "Превышение скорости(от 40 до 60)", Null,  "2020-02-14", Null),
("Абрамова К.А.", "О111АВ", "Проезд на запрещающий сигнал", Null,  "2020-02-23", Null),
("Яковлев Г.Р.", "Т330ТТ", "Проезд на запрещающий сигнал", Null,  "2020-03-03", Null);
```
Пояснение

1. Между формулировкой нарушения и открывающей скобкой ПРОБЕЛА НЕТ. Например, Превышение скорости(от 40 до 60). 
2. Для занесения пустых значений в поля используется оператор Null.
3. Номера машин записывать РУССКИМИ буквами.

### Использование временного имени таблицы (алиаса)

Чтобы не писать название таблицы каждый раз, удобно использовать алиасы.

Алиас, это псевдоним, который мы присваивали столбцам после ключевого слова AS(шаг).  Алиасы так же можно использовать и для таблиц. Это становится актуальным, при увеличении числа используемых таблиц, их иногда может быть и 5 и 10 и более. Псевдонимы помогают сделать запрос чище и читабельнее.

Для присваивания псевдонима существует 2 варианта: 

с использованием ключевого слова AS 
``` 
FROM fine AS f, traffic_violation AS tv
```
а так же и без него
```
FROM fine f, traffic_violation tv
```
После присвоения таблице алиаса, он используется во всех разделах запроса, в котором алиас задан. Например:
```
WHERE f.violation = tv.violation
```
Пример

Для тех, кто уже оплатил штраф, вывести информацию о том, изменялась ли стандартная сумма штрафа.

Запрос:
```
SELECT  f.name, f.number_plate, f.violation, 
   if(
    f.sum_fine = tv.sum_fine, "Стандартная сумма штрафа", 
    if(
      f.sum_fine < tv.sum_fine, "Уменьшенная сумма штрафа", "Увеличенная сумма штрафа"
    )
  ) AS description               
FROM  fine f, traffic_violation tv
WHERE tv.violation = f.violation and f.sum_fine IS NOT Null;
```
Задание

Занести в таблицу fine суммы штрафов, которые должен оплатить водитель, в соответствии с данными из таблицы traffic_violation. При этом суммы заносить только в пустые поля столбца  sum_fine.

Таблица traffic_violation создана и заполнена.

Важно! Сравнение значения столбца с пустым значением осуществляется с помощью оператора IS NULL.

Пояснение
1. После ключевого слова UPDATE кроме обновляемой таблицы fine укажите таблицу traffic_violation, для того чтобы запрос
видел таблицы источники.  Сначала перечисляем все источники, потом выполняем необходимые действия.

2. Обновляйте только те записи таблицы fine, у которых значение столбца violationсовпадает со значением соответствующего столбца таблицы traffic_violation, а также значение столбца sum_fine пусто.

```
UPDATE fine f, traffic_violation tv
SET f.sum_fine = tv.sum_fine
WHERE f.violation = tv.violation AND f.sum_fine IS NULL;
```
---

### Группировка данных по нескольким столбцам

В разделе GROUP BY можно указывать несколько столбцов, разделяя их запятыми. Тогда к одной группе будут относиться записи, у которых значения столбцов, входящих в группу, равны. Рассмотрим группировку по нескольким столбцам на примере следующего запроса:
```
SELECT name, number_plate, violation, count(*)
FROM fine
GROUP BY name, number_plate, violation;
```
1. Сначала записи таблицы fine разделяются на группы. В каждую группу включаются строки, у которых равны значения 
в столбцах name, number_plate и violation  соответственно. Получается 6 групп. 

2. Затем вычисляется функция count(*), которая определяет количество записей в каждой группе. Получается, что к первым двум группам относятся по две записи, ко всем остальным - по одной.

Важно! 

В разделе GROUP BY нужно перечислять все НЕАГРЕГИРОВАННЫЕ столбцы (к которым не применяются групповые функции) из SELECT.

Задание

Вывести фамилию, номер машины и нарушение только для тех водителей, которые на одной машине нарушили одно и то же правило   два и более раз. При этом учитывать все нарушения, независимо от того оплачены они или нет. Информацию отсортировать в алфавитном порядке, сначала по фамилии водителя, потом по номеру машины и, наконец, по нарушению.

Пояснение

Под увеличение  штрафа в два раза подходит водитель «Абрамова К.А.», который на машине с государственным номером «О111АВ» совершил повторное нарушение «Проезд на запрещающий сигнал», а также водитель  «Баранов П.Е.» , который на машине с номером  «Р523ВТ» дважды совершил нарушение «Превышение скорости(от 40 до 60) ».

```
SELECT name, number_plate, violation
FROM fine
GROUP BY 1, 2, 3
HAVING count(name) > 1
ORDER BY 1, 2, 3;
```
---

В таблице fine увеличить в два раза сумму неоплаченных штрафов для отобранных на предыдущем шаге записей. 

Пояснение !!!

если не получается запрос или валидатор выдает ошибки, раскройте это пояснение!!!
Для всех нарушений, по которым штраф еще не оплачен, (тех, у которых date_payment имеет пустое значение Null), необходимо проверить, является ли данное нарушение для водителя и машины повторным, если да –  увеличить штраф в два раза.
Если водитель совершил нарушение на другой машине, ему увеличивать штраф не нужно.
Если несколько повторных нарушений не оплачены, то штраф увеличить для всех.
Этот запрос реализован на предыдущем шаге.
При реализации можно использовать вложенный запрос как отдельную таблицу, записанную после ключевого слова UPDATE, при этом вложенному запросу необходимо присвоить имя, например query_in:
```
UPDATE fine, 
    (
     SELECT ...
    ) query_in
SET ...
WHERE указать, что совпадают нарушение, фамилия водителя и номер машины в таблицах fine и вложенном запросе query_in соответственно, а также дата оплаты в таблице fine пуста
```
Другим способом решения является использование двух запросов: сначала создать временную таблицу, например query_in, в которую включить информацию о тех штрафах, сумму которых нужно увеличить в два раза, а затем уже обновлять информацию в таблице fine:
```
CREATE TABLE query_in ...;

UPDATE fine, query_in
SET ...
WHERE ...;
```
После ключевого слова WHERE  указывается условие, при котором нужно обновлять данные. В нашем случае  данные обновляются, если и фамилия, и государственный номер, и нарушение совпадают в таблице fine и в результирующей таблице запроса query_in. Например, для связи по фамилии используется запись fine.name = query_in.name. Также в условии нужно учесть, что данные обновляются только для тех записей, у которых в столбце date_payment пусто.

Важно! Если в запросе используется несколько таблиц или запросов, включающих одинаковые поля, то применяется полное имя столбца, включающего название таблицы через символ «.». Например,  fine.name  и  query_in.name.

```
UPDATE fine, 
    (
     SELECT name, number_plate, violation
FROM fine
GROUP BY 1, 2, 3
HAVING count(name) > 1
ORDER BY 1, 2, 3
    ) query_in
SET sum_fine = sum_fine * 2
WHERE fine.name = query_in.name AND fine.number_plate = query_in.number_plate
AND fine.date_payment IS NULL
```
---

Задание

Водители оплачивают свои штрафы. В таблице payment занесены даты их оплаты:

Необходимо:

- в таблицу fine занести дату оплаты соответствующего штрафа из таблицы payment; 
- уменьшить начисленный штраф в таблице fine в два раза (только для тех штрафов, информация о которых занесена в таблицу 
payment), если оплата произведена не позднее 20 дней со дня нарушения.

```
UPDATE fine f, payment p
SET f.date_payment = p.date_payment, 
f.sum_fine = IF(DATEDIFF(p.date_payment, p.date_violation)<21, f.sum_fine * 0.5, f.sum_fine)
WHERE f.name = p.name AND f.number_plate = p.number_plate
AND f.violation = p.violation
AND f.date_violation = p.date_violation;
```
---
Задание

Создать новую таблицу back_payment, куда внести информацию о неоплаченных штрафах (Фамилию и инициалы водителя, номер машины, нарушение, сумму штрафа  и  дату нарушения) из таблицы fine.

Пояснение

Для неоплаченных штрафов столбец date_payment имеет пустое значение.

Важно. На этом шаге необходимо создать таблицу на основе запроса! Не нужно одним запросом создавать таблицу, а вторым в нее добавлять строки.

```
CREATE TABLE back_payment AS
SELECT name, number_plate, violation, sum_fine, date_violation
FROM fine
WHERE date_payment IS NULL;

SELECT * FROM back_payment;
```
---
Задание

Удалить из таблицы fine информацию о нарушениях, совершенных раньше 1 февраля 2020 года. 
```
DELETE FROM fine 
WHERE date_violation < '2020-02-01';

SELECT * FROM fine;
```
